<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DataHandling · ClimaUtilities.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ClimaUtilities.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaUtilities.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../datastructures/">Data Structures</a></li><li><a class="tocitem" href="../climaartifacts/">ClimaArtifacts</a></li><li><a class="tocitem" href="../inputs/">Space and Time Inputs</a></li><li><a class="tocitem" href="../filereaders/">FileReaders</a></li><li class="is-active"><a class="tocitem" href>DataHandling</a><ul class="internal"><li><a class="tocitem" href="#Example:-Linear-interpolation-of-a-single-data-variable"><span>Example: Linear interpolation of a single data variable</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../regridders/">Regridders</a></li><li><a class="tocitem" href="../onlinelogging/">OnlineLogging</a></li><li><a class="tocitem" href="../outputpathgenerator/">OutputPathGenerator</a></li><li><a class="tocitem" href="../timemanager/">TimeManager</a></li><li><a class="tocitem" href="../faqs/">Frequently Asked Questions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DataHandling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DataHandling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaUtilities.jl/blob/main/docs/src/datahandling.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="datahandling_module"><a class="docs-heading-anchor" href="#datahandling_module"><code>DataHandling</code></a><a id="datahandling_module-1"></a><a class="docs-heading-anchor-permalink" href="#datahandling_module" title="Permalink"></a></h1><p>The <code>DataHandling</code> module is responsible for reading data from files and resampling it onto the simulation grid.</p><p>This is no trivial task. Among the challenges:</p><ul><li>data can be large and cannot be read all in one go and/or held in memory,</li><li>regridding onto the simulation grid can be very expensive,</li><li>IO can be very expensive,</li><li>CPU/GPU communication can be a bottleneck.</li></ul><p>The <code>DataHandling</code> takes the divide-and-conquer approach: the various core tasks and features and split into other independent modules (chiefly <a href="../filereaders/#file_reader_module"><code>FileReaders</code></a>, and <a href="../regridders/#regridder_module"><code>Regridders</code></a> regridder_module). Such modules can be developed, tested, and extended independently (as long as they maintain a consistent interface). For instance, if need arises, the <code>DataHandler</code> can be used (almost) directly to process files with a different format from NetCDF.</p><p>The key struct in <code>DataHandling</code> is the <code>DataHandler</code>. The <code>DataHandler</code> contains one or more <code>FileReader</code>(s), a <code>Regridder</code>, and other metadata necessary to perform its operations (e.g., target <code>ClimaCore.Space</code>). The <code>DataHandler</code> can be used for static or temporal data, and exposes the following key functions:</p><ul><li><code>regridded_snapshot(time)</code>: to obtain the regridded field at the given <code>time</code>.                   <code>time</code> has to be available in the data.</li><li><code>available_times</code> (<code>available_dates</code>): to list all the <code>times</code> (<code>dates</code>) over                   which the data is defined.</li><li><code>previous_time(time/date)</code> (<code>next_time(time/date)</code>): to obtain the time of the                        snapshot before the given <code>time</code> or <code>date</code>. This can be                        used to compute the interpolation weight for linear                        interpolation, or in combination with                        <code>regridded_snapshot</code> to read a particular snapshot</li></ul><p>Most <code>DataHandling</code> functions take either <code>time</code> or <code>date</code>, with the difference being that <code>time</code> is intended as &quot;simulation time&quot; and is expected to be in seconds; <code>date</code> is a calendar date (from <code>Dates.DateTime</code>). Conversion between time and date is performed using the reference date and simulation starting time provided to the <code>DataHandler</code>.</p><p>The <code>DataHandler</code> has a caching mechanism in place: once a field is read and regridded, it is stored in the local cache to be used again (if needed). This is a least-recently-used (LRU) cache implemented in <code>DataStructures</code>, which removes the least-recently-used data when its maximum size is reached. The default maximum size is 128.</p><p>While the reading backend could be generic, at the moment, this module uses only the <code>NCFileReader</code>.</p><blockquote><p>This extension is loaded when loading <code>ClimaCore</code> and <code>NCDatasets</code> are loaded. In addition to this, a <code>Regridder</code> is needed (which might require importing additional packages) - see <a href="../regridders/#regridder_module"><code>Regridders</code></a> for more information.</p></blockquote><p>It is possible to pass down keyword arguments to underlying constructors in <code>DataHandler</code> with the <code>regridder_kwargs</code> and <code>file_reader_kwargs</code>. These have to be a named tuple or a dictionary that maps <code>Symbol</code>s to values.</p><p>A <code>DataHandler</code> can contain information about a variable that we read directly from an input file, or about a variable that is produced by composing data from multiple input variables. In the latter case, the input variables may either all come from the same input file, or may each come from a separate input file. The user must provide the composing function, which operates pointwise on each of the inputs, as well as an ordered list of the variable names to be passed to the function. Additionally, input variables that are composed together must have the same spatial and temporal dimensions. Note that, if a non-identity pre-processing function is provided as part of <code>file_reader_kwargs</code>, it will be applied to each input variable before they are composed. Composing multiple input variables is currently only supported with the <a href="../regridders/#interp_regridder"><code>InterpolationsRegridder</code></a>, not with <a href="../regridders/#tempest_regridder"><code>TempestRegridder</code></a>.</p><p>Sometimes, the time development of a variable is split across multiple NetCDF files. <code>DataHandler</code> knows how to combine them and treat multiple files as if they were a single one. To use this feature, just pass the list of NetCDF files (while the file don&#39;t have to be sorted, it is good practice to pass them sorted in ascending order by time).</p><h4 id="Heuristics-to-do-what-you-mean"><a class="docs-heading-anchor" href="#Heuristics-to-do-what-you-mean">Heuristics to do-what-you-mean</a><a id="Heuristics-to-do-what-you-mean-1"></a><a class="docs-heading-anchor-permalink" href="#Heuristics-to-do-what-you-mean" title="Permalink"></a></h4><p><code>DataHandler</code> tries to interpret the files provided and identify if they are split across variables or along the time dimension. The heuristics implement are the following:</p><ul><li>When just a file is passed, it is assumed that it contains everything</li><li>When multiple files are passed, <code>DataHandler</code> will assume that the files are split along variables if the number of files is the same the number of variables, otherwise, it will assume that each file contains all the variables for a portion of the total time.</li><li>When the above assumption is incorrect, you can pass a list of list of files that fully specifies variables and times.</li></ul><p>For example,</p><pre><code class="language-julia hljs">data_handler = DataHandling.DataHandler(
    [&quot;era1980.nc&quot;, &quot;era1981.nc&quot;],
    [&quot;lai_hv&quot;, &quot;lai_lv&quot;],
    target_space;
    compose_function = (x, y) -&gt; x + y,
)</code></pre><p>In this case, <code>DataHandler</code> will incorrectly assume that <code>lai_hv</code> is contained in <code>era1980.nc</code>, and <code>lai_lv</code> is in <code>era1980.nc</code>. Instead, construct the <code>data_handler</code> by passing a list of lists</p><pre><code class="language-julia hljs">files = [&quot;era1980.nc&quot;, &quot;era1981.nc&quot;]
data_handler = DataHandling.DataHandler(
    [files, files],
    [&quot;lai_hv&quot;, &quot;lai_lv&quot;],
    target_space;
    compose_function = (x, y) -&gt; x + y,
)</code></pre><p>where each element of the list is the collection of files that contain the time evolution of that variable.</p><h2 id="Example:-Linear-interpolation-of-a-single-data-variable"><a class="docs-heading-anchor" href="#Example:-Linear-interpolation-of-a-single-data-variable">Example: Linear interpolation of a single data variable</a><a id="Example:-Linear-interpolation-of-a-single-data-variable-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Linear-interpolation-of-a-single-data-variable" title="Permalink"></a></h2><p>As an example, let us implement a simple linear interpolation for a variable <code>u</code> defined in the <code>era5_example.nc</code> NetCDF file. The file contains monthly averages starting from the year 2000.</p><pre><code class="language-julia hljs">import ClimaUtilities.DataHandling
import ClimaCore
import NCDatasets
# Loading ClimaCore and Interpolations automatically loads DataHandling
import Interpolations
# This will load InterpolationsRegridder

import Dates

# Define pre-processing function to convert units of input
unit_conversion_func = (data) -&gt; 1000 * data

data_handler = DataHandling.DataHandler(&quot;era5_example.nc&quot;,
                                        &quot;u&quot;,
                                        target_space,
                                        start_date = Dates.DateTime(2000, 1, 1),
                                        regridder_type = :InterpolationsRegridder,
                                        file_reader_kwargs = (; preprocess_func = unit_conversion_func))

function linear_interpolation(data_handler, time)
    # Time is assumed to be &quot;simulation time&quot;, ie seconds starting from start_date

    time_of_prev_snapshot = DataHandling.previous_time(data_handler, time)
    time_of_next_snapshot = DataHandling.next_time(data_handler, time)

    prev_snapshot = DataHandling.regridded_snaphsot(data_handler, time_of_prev_snapshot)
    next_snapshot = DataHandling.regridded_snaphsot(data_handler, time_of_next_snapshot)

    # prev and next snapshots are ClimaCore.Fields defined on the target_space

    return @. prev_snapshot + (next_snapshot - prev_snapshot) *
        (time - time_of_prev_snapshot) / (time_of_next_snapshot - time_of_prev_snapshot)
end</code></pre><p>If, for example, the data was split across multiple files named <code>era5_1980.nc</code>, <code>era5_1981.nc</code>, ... (e.g., each file containing one year), we could directly pass the list to the constructor for <code>DataHandler</code> (instead of just passing one file path), which knows how to combine them.</p><h3 id="Example-appendix:-Using-multiple-input-data-variables"><a class="docs-heading-anchor" href="#Example-appendix:-Using-multiple-input-data-variables">Example appendix: Using multiple input data variables</a><a id="Example-appendix:-Using-multiple-input-data-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Example-appendix:-Using-multiple-input-data-variables" title="Permalink"></a></h3><p>Suppose that the input NetCDF file <code>era5_example.nc</code> contains two variables <code>u</code> and <code>v</code>, and we care about their sum <code>u + v</code> but not their individual values. We can provide a pointwise composing function to perform the sum, along with the <a href="../regridders/#interp_regridder"><code>InterpolationsRegridder</code></a> to produce the data we want, <code>u + v</code>. The <code>preprocess_func</code> passed in <code>file_reader_kwargs</code> will be applied to <code>u</code> and to <code>v</code> individually, before the composing function is applied. The regridding is applied after the composing function. <code>u</code> and <code>v</code> could also come from separate NetCDF files, but they must still have the same spatial and temporal dimensions.</p><pre><code class="language-julia hljs"># Define the pointwise composing function we want, a simple sum in this case
compose_function = (x, y) -&gt; x + y
data_handler = DataHandling.DataHandler(&quot;era5_example.nc&quot;,
                                        [&quot;u&quot;, &quot;v&quot;],
                                        target_space,
                                        start_date = Dates.DateTime(2000, 1, 1),
                                        regridder_type = :InterpolationsRegridder,
                                        file_reader_kwargs = (; preprocess_func = unit_conversion_func),
                                        compose_function)</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.DataHandler" href="#ClimaUtilities.DataHandling.DataHandler"><code>ClimaUtilities.DataHandling.DataHandler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DataHandler(file_paths,
            varnames,
            target_space::ClimaCore.Spaces.AbstractSpace;
            start_date::Dates.DateTime = Dates.DateTime(1979, 1, 1),
            regridder_type = nothing,
            cache_max_size::Int = 2,
            regridder_kwargs = (),
            file_reader_kwargs = ())</code></pre><p>Create a <code>DataHandler</code> to read <code>varnames</code> from <code>file_paths</code> and remap them to <code>target_space</code>.</p><p>This function supports reading across multiple files and composing variables that are in different files.</p><p><code>file_paths</code> may contain either one path for all variables or one path for each variable. In the latter case, the entries of <code>file_paths</code> and <code>varnames</code> are expected to match based on position.</p><p>The DataHandler maintains an LRU cache of Fields that were previously computed. The default size for the cache is only two fields, so if you expect to re-use the same fields often, increasing the cache size can lead to improved performances.</p><p>Creating this object results in the file being accessed (to preallocate some memory).</p><p><strong>Positional arguments</strong></p><ul><li><p><code>file_paths</code>: Paths of the NetCDF file(s) that contain the input data. <code>file_paths</code> should be as &quot;do-what-I-mean&quot; as possible, meaning that it should behave as you expect.</p><p>To be specific, there are three options for <code>file_paths</code>:</p><ul><li>It is a string that points to a single NetCDF file.</li><li>It is a list that points to multiple NetCDF files. In this case, we support two modes:<ol><li>if <code>varnames</code> is a vector with the number of entries as <code>file_paths</code>, we assume that each file contains a different variable.</li><li>otherwise, we assume that each file contains all the variables and is temporal chunk.</li></ol></li><li>It is a list of lists of paths to NetCDF files, where the inner list identifies temporal chunks of a given variable, and the outer list identifies different variables (supporting the mode where different variables live in different files and their time development is split across multiple files). In other words, <code>file_paths[i]</code> is the list of files that define the temporal evolution of <code>varnames[i]</code></li></ul></li><li><p><code>varnames</code>: Names of the datasets in the NetCDF that have to be read and processed.</p></li><li><p><code>target_space</code>: Space where the simulation is run, where the data has to be regridded to.</p></li></ul><p><strong>Keyword arguments</strong></p><p>Time/date information will be ignored for static input files. (They are still set to make everything more type stable.)</p><ul><li><code>start_date</code>: Calendar date corresponding to the start of the simulation.</li><li><code>regridder_type</code>: What type of regridding to perform. Currently, the ones implemented are                   <code>:TempestRegridder</code> (using <code>TempestRemap</code>) and                   <code>:InterpolationsRegridder</code> (using <code>Interpolations.jl</code>). <code>TempestRemap</code>                   regrids everything ahead of time and saves the result to HDF5 files.                   <code>Interpolations.jl</code> is online and GPU compatible but not conservative.                   If the regridder type is not specified by the user, and multiple are                   available, the default <code>:InterpolationsRegridder</code> regridder is used.</li><li><code>cache_max_size</code>: Maximum number of regridded fields to store in the cache. If the cache                   is full, the least recently used field is removed.</li><li><code>regridder_kwargs</code>: Additional keywords to be passed to the constructor of the regridder.                     It can be a NamedTuple, or a Dictionary that maps Symbols to values.</li><li><code>file_reader_kwargs</code>: Additional keywords to be passed to the constructor of the file reader.                       It can be a NamedTuple, or a Dictionary that maps Symbols to values.</li><li><code>compose_function</code>: Function to combine multiple input variables into a single data                     variable. The default, to be used in the case of one input variable,                     is the identity. The compose function has to take N arguments, where                     N is the number of variables in <code>varnames</code>, and return a scalar.                     The order of the arguments in <code>compose_function</code> has to match the order                     of <code>varnames</code>. This function will be broadcasted to data read from file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L127-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.available_times" href="#ClimaUtilities.DataHandling.available_times"><code>ClimaUtilities.DataHandling.available_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">available_times(data_handler::DataHandler)</code></pre><p>Return the time in seconds of the snapshots in the data, measured considering the starting time of the simulation and the reference date</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L385-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.available_dates" href="#ClimaUtilities.DataHandling.available_dates"><code>ClimaUtilities.DataHandling.available_dates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">available_dates(data_handler::DataHandler)</code></pre><p>Return the dates of the snapshots in the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L395-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.previous_time" href="#ClimaUtilities.DataHandling.previous_time"><code>ClimaUtilities.DataHandling.previous_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">previous_time(data_handler::DataHandler, time::AbstractFloat)
previous_time(data_handler::DataHandler, date::Dates.DateTime)</code></pre><p>Return the time in seconds of the snapshot before the given <code>time</code>. If <code>time</code> is one of the snapshots, return itself.</p><p>If <code>time</code> is not in the <code>data_handler</code>, return an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L457-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.next_time" href="#ClimaUtilities.DataHandling.next_time"><code>ClimaUtilities.DataHandling.next_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">next_time(data_handler::DataHandler, time::AbstractFloat)
next_time(data_handler::DataHandler, date::Dates.DateTime)</code></pre><p>Return the time in seconds of the snapshot after the given <code>time</code>. If <code>time</code> is one of the snapshots, return the next time.</p><p>If <code>time</code> is not in the <code>data_handler</code>, return an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L488-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.previous_date" href="#ClimaUtilities.DataHandling.previous_date"><code>ClimaUtilities.DataHandling.previous_date</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DataHandling.previous_date(data_handler::DataHandler, time::Dates.TimeType)</code></pre><p>Return the date of the snapshot before the given <code>date</code>. If <code>date</code> is one of the snapshots, return itself.</p><p>If <code>date</code> is not in the <code>data_handler</code>, return an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L514-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.next_date" href="#ClimaUtilities.DataHandling.next_date"><code>ClimaUtilities.DataHandling.next_date</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DataHandling.next_date(data_handler::DataHandler, time::Dates.TimeType)</code></pre><p>Return the date of the snapshot after the given <code>time</code>. If <code>date</code> is one of the snapshots, return itself.</p><p>If <code>date</code> is not in the <code>data_handler</code>, return an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L535-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.regridded_snapshot" href="#ClimaUtilities.DataHandling.regridded_snapshot"><code>ClimaUtilities.DataHandling.regridded_snapshot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regridded_snapshot(data_handler::DataHandler, date::Dates.DateTime)
regridded_snapshot(data_handler::DataHandler, time::AbstractFloat)
regridded_snapshot(data_handler::DataHandler)</code></pre><p>Return the regridded snapshot from <code>data_handler</code> associated to the given <code>time</code> (if relevant).</p><p>The <code>time</code> has to be available in the <code>data_handler</code>.</p><p>When using multiple input variables, the <code>varnames</code> argument determines the order of arguments to the <code>compose_function</code> function used to produce the data variable.</p><p><code>regridded_snapshot</code> potentially modifies the internal state of <code>data_handler</code> and it might be a very expensive operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L554-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.regridded_snapshot!" href="#ClimaUtilities.DataHandling.regridded_snapshot!"><code>ClimaUtilities.DataHandling.regridded_snapshot!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regridded_snapshot!(dest::ClimaCore.Fields.Field, data_handler::DataHandler, date::Dates.DateTime)</code></pre><p>Write to <code>dest</code> the regridded snapshot from <code>data_handler</code> associated to the given <code>time</code>.</p><p>The <code>time</code> has to be available in the <code>data_handler</code>.</p><p><code>regridded_snapshot!</code> potentially modifies the internal state of <code>data_handler</code> and it might be a very expensive operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L638-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.dt" href="#ClimaUtilities.DataHandling.dt"><code>ClimaUtilities.DataHandling.dt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dt(data_handler::DataHandler)</code></pre><p>Return the time interval between data points for the data in <code>data_handler</code>.</p><p>This requires the data to be defined on a equispaced temporal mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L404-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.time_to_date" href="#ClimaUtilities.DataHandling.time_to_date"><code>ClimaUtilities.DataHandling.time_to_date</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_to_date(data_handler::DataHandler, time::AbstractFloat)</code></pre><p>Convert the given time to a calendar date.</p><pre><code class="nohighlight hljs">date = start_date + time</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L419-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.DataHandling.date_to_time" href="#ClimaUtilities.DataHandling.date_to_time"><code>ClimaUtilities.DataHandling.date_to_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">date_to_time(data_handler::DataHandler, time::AbstractFloat)</code></pre><p>Convert the given calendar date to a time (in seconds).</p><pre><code class="nohighlight hljs">date = start_date + time</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/634f86e75006555920df0ee6e90eaca1a7c7f16f/ext/DataHandlingExt.jl#L441-L449">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../filereaders/">« FileReaders</a><a class="docs-footer-nextpage" href="../regridders/">Regridders »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 16 January 2025 17:58">Thursday 16 January 2025</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
