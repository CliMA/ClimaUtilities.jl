<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TimeManager · ClimaUtilities.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ClimaUtilities.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaUtilities.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../datastructures/">Data Structures</a></li><li><a class="tocitem" href="../climaartifacts/">ClimaArtifacts</a></li><li><a class="tocitem" href="../inputs/">Space and Time Inputs</a></li><li><a class="tocitem" href="../filereaders/">FileReaders</a></li><li><a class="tocitem" href="../datahandling/">DataHandling</a></li><li><a class="tocitem" href="../regridders/">Regridders</a></li><li><a class="tocitem" href="../onlinelogging/">OnlineLogging</a></li><li><a class="tocitem" href="../outputpathgenerator/">OutputPathGenerator</a></li><li class="is-active"><a class="tocitem" href>TimeManager</a><ul class="internal"><li><a class="tocitem" href="#ITime"><span><code>ITime</code></span></a></li><li><a class="tocitem" href="#Developer-notes"><span>Developer notes</span></a></li><li><a class="tocitem" href="#TimeManager-API"><span>TimeManager API</span></a></li></ul></li><li><a class="tocitem" href="../faqs/">Frequently Asked Questions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>TimeManager</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>TimeManager</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaUtilities.jl/blob/main/docs/src/timemanager.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TimeManager"><a class="docs-heading-anchor" href="#TimeManager">TimeManager</a><a id="TimeManager-1"></a><a class="docs-heading-anchor-permalink" href="#TimeManager" title="Permalink"></a></h1><p><code>TimeManager</code> defines <code>ITime</code>, the time type for CliMA simulations, alongside with various functions to work with it.</p><h2 id="ITime"><a class="docs-heading-anchor" href="#ITime"><code>ITime</code></a><a id="ITime-1"></a><a class="docs-heading-anchor-permalink" href="#ITime" title="Permalink"></a></h2><p><code>ITime</code> is a type to describe times and dates. The &quot;I&quot; in <code>ITime</code> stands for <em>integer</em>: internally, <code>ITime</code> uses integers to represent times and dates, meaning that operations with <code>ITime</code> are exact and do not occur in floating-point errors.</p><p><code>ITime</code> can be thought a combination of three quantities, a <code>counter</code>, a <code>period</code>, and (optionally) an <code>epoch</code>, with the <code>counter</code> counting how many <code>period</code>s have elapsed since <code>epoch</code>. In other words, <code>ITime</code> counts clock cycles from an epoch, with each clock cycle lasting a <code>period</code>.</p><p>Another useful mental model for <code>ITime</code> is that it is a time with some units. It is useful to keep this abstraction in mind when working with binary operations that involve <code>ITime</code>s because it helps with determining the output type of the operation (more on this later).</p><p>Let us start getting familiar with <code>ITime</code> by exploring some basic operations.</p><h3 id="First-steps-with-ITime"><a class="docs-heading-anchor" href="#First-steps-with-ITime">First steps with <code>ITime</code></a><a id="First-steps-with-ITime-1"></a><a class="docs-heading-anchor-permalink" href="#First-steps-with-ITime" title="Permalink"></a></h3><p>The first step in using <code>ITime</code> is to load it. You can load <code>ITime</code> by loading the <code>TimeManager</code> module as in the following:</p><pre><code class="language-julia hljs">using ClimaUtilities.TimeManager</code></pre><p>This will load <code>ITime</code> as well as some other utilities. If you only wish to load <code>ITime</code>, you can change <code>using</code> with <code>import</code> and explicitly ask for <code>ITime</code></p><pre><code class="language- hljs">import ClimaUtilities.TimeManager: ITime</code></pre><p>In these examples, we will stick with <code>using ClimaUtilites.TimeManager</code> because we will call other functions as well.</p><p>By default, <code>ITime</code> assumes that the clock cycle is one second:</p><pre><code class="language-julia hljs">ITime(5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.0 seconds [counter = 5, period = 1 second]</code></pre><p>The output that is printed shows the time represented (5 seconds), and its break down into the integer counter (5) and the duration of each clock cycle (1 second).</p><p>This <code>ITime</code> does not come with any date information attached to it. To add it, you can pass the <code>epoch</code> keyword</p><pre><code class="language-julia hljs">using Dates
ITime(5; epoch = DateTime(2012, 12, 21))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.0 seconds (2012-12-21T00:00:05) [counter = 5, period = 1 second, epoch = 2012-12-21T00:00:00]</code></pre><p>Now, the output also reports <code>epoch</code> and current date (5 seconds after midnight of the 21st of December 2012).</p><p>The period can also be customized with the <code>period</code> keyword. This keyword accepts any <code>Dates.FixedPeriod</code> (fixed periods are intervals of time that have a fixed duration, such as <code>Week</code>, but unlike <code>Month</code>), for example</p><pre><code class="language-julia hljs">time1 = ITime(5; period = Hour(20), epoch = DateTime(2012, 12, 21))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100.0 hours (2012-12-25T04:00:00) [counter = 5, period = 20 hours, epoch = 2012-12-21T00:00:00]</code></pre><p>All these quantities are accessible with functions:</p><pre><code class="language-julia hljs">@show &quot;time1&quot; counter(time1) period(time1) epoch(time1) date(time1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2012-12-25T04:00:00</code></pre><p>Now that we know how to create <code>ITime</code>s, we can manipulate them. <code>ITime</code>s support most (but not all) arithmetic operations.</p><p>For <code>ITime</code>s with an <code>epoch</code>, it is only possible to combine <code>ITime</code>s that have the same <code>epoch</code>. <code>ITime</code>s can be composed to other times and arithmetic operations propagate <code>epoch</code>s.</p><p>This works:</p><pre><code class="language-julia hljs">time1 = ITime(5; epoch = DateTime(2012, 12, 21))
time2 = ITime(15; epoch = DateTime(2012, 12, 21))
time1 + time2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">20.0 seconds (2012-12-21T00:00:20) [counter = 20, period = 1 second, epoch = 2012-12-21T00:00:00]</code></pre><p>This works too</p><pre><code class="language-julia hljs">time1 = ITime(5; epoch = DateTime(2012, 12, 21))
time2 = ITime(15)
time1 + time2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">20.0 seconds (2012-12-21T00:00:20) [counter = 20, period = 1 second, epoch = 2012-12-21T00:00:00]</code></pre><p>This does not work because the two <code>ITimes</code> don&#39;t have the same <code>epoch</code></p><pre><code class="language-julia hljs">time1 = ITime(5; epoch = DateTime(2012, 12, 21))
time2 = ITime(15; epoch = DateTime(2025, 12, 21))
time1 + time2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Cannot find common epoch</code></pre><p>When dealing with binary operations, it is convenient to think of <code>ITime</code>s as dimensional quantities (quantities with units). In the previous examples, addition returns a new <code>ITime</code>s. Division will behave differently</p><pre><code class="language-julia hljs">time1 = ITime(15)
time2 = ITime(5)
time1 / time2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3//1</code></pre><p>In this case, the return value is just a number (essentially, we divided 15 seconds by 5 seconds, resulting the dimensionless factor of 3).</p><p>Similarly, adding a number to an <code>ITime</code> is not allowed (because the number doesn&#39;t have units), but multiplying by is fine.</p><p>In the same spirit, when <code>ITime</code>s with different <code>periods</code> are combined, units are transformed to the</p><pre><code class="language-julia hljs">time1 = ITime(5; period = Hour(1))
time2 = ITime(1; period = Minute(25))
time1 - time2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">275.0 minutes [counter = 55, period = 5 minutes]</code></pre><p>As we can see, the return value of 5 hours - 25 minutes is 275 minutes and it is represented as 55 clock cycles of a period of 5 minutes. <code>Minute(5)</code> was picked because it the greatest common divisor between <code>Hour(1)</code> and <code>Minute(25)</code>.</p><p>At any point, we can obtain a date or a number of seconds from an <code>ITime</code>:</p><pre><code class="language-julia hljs">time1 = ITime(5; period = Day(10), epoch = DateTime(2012, 12, 21))
date(time1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2013-02-09T00:00:00</code></pre><p>And</p><pre><code class="language-julia hljs">time1 = ITime(5; period = Day(10), epoch = DateTime(2012, 12, 21))
seconds(time1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4.32e6</code></pre><p>In this, note that the <code>seconds</code> function always returns a Float64.</p><p>In this section, we saw that <code>ITime</code>s can be used to represent dates and times and manipulated in a natural way.</p><p><code>ITime</code>s support another feature, fractional times, useful for further partitioning an interval of time.</p><h3 id="Dealing-with-times-that-cannot-be-represented"><a class="docs-heading-anchor" href="#Dealing-with-times-that-cannot-be-represented">Dealing with times that cannot be represented</a><a id="Dealing-with-times-that-cannot-be-represented-1"></a><a class="docs-heading-anchor-permalink" href="#Dealing-with-times-that-cannot-be-represented" title="Permalink"></a></h3><p>Sometimes, one need to work with fractions of a <code>period</code>. The primary application of this is timestepping loops, which are typically divided in stages which are a fraction of a timestep.</p><p>In these cases, we round to the nearest amount representable as an <code>ITime</code>. Furthermore, these cases are constrained to only when an <code>ITime</code> is multiplied by a float between zero and one. These are the only cases we consider, because the only instance in which the problem of handling fraction of a <code>period</code> is in the timestepping loops.</p><p>See the examples below.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; time = ITime(1; period = Hour(1), epoch = DateTime(2012, 12, 21))</code><code class="nohighlight hljs ansi" style="display:block;">1.0 hour (2012-12-21T01:00:00) [counter = 1, period = 1 hour, epoch = 2012-12-21T00:00:00]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 0.3 * time # round down</code><code class="nohighlight hljs ansi" style="display:block;">0.0 hours (2012-12-21T00:00:00) [counter = 0, period = 1 hour, epoch = 2012-12-21T00:00:00]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 0.5 * time # round down</code><code class="nohighlight hljs ansi" style="display:block;">0.0 hours (2012-12-21T00:00:00) [counter = 0, period = 1 hour, epoch = 2012-12-21T00:00:00]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 0.7 * time # round up</code><code class="nohighlight hljs ansi" style="display:block;">1.0 hour (2012-12-21T01:00:00) [counter = 1, period = 1 hour, epoch = 2012-12-21T00:00:00]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 1.2 * time # error because 1.2 &gt; 1.0</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: In most cases, multiplying an ITime by a float is not desirable. Cast the ITime into a float</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; -0.2 * time # error because -0.2 &lt; 0.0</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: In most cases, multiplying an ITime by a float is not desirable. Cast the ITime into a float</code></pre><p>If multiplication between an <code>ITime</code> and a float is needed, you most likely want to cast the <code>ITime</code> into a float. For example, in functions that compute tendencies, there are no operations that are of the form <code>t + a * dt</code> where <code>a</code> is a float, so it is safe to cast the <code>ITime</code> into a float as it will not lead to a loss of accuracy in time.</p><p>In cases where you compute an expression of the form <code>t + a * dt</code> where <code>a</code> is a float or something similar, then rounding occurs. For packages like ClimaTimeSteppers, this means that any time stepping stages will incur a slight inaccuracy in the time if the period is not divisible by <code>dt</code>.</p><h3 id="How-to-use-ITimes-in-packages"><a class="docs-heading-anchor" href="#How-to-use-ITimes-in-packages">How to use <code>ITime</code>s in packages</a><a id="How-to-use-ITimes-in-packages-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use-ITimes-in-packages" title="Permalink"></a></h3><p>The two key interfaces to work with <code>ITime</code>s are <a href="#ClimaUtilities.TimeManager.seconds"><code>ClimaUtilities.TimeManager.seconds</code></a> and <a href="#ClimaUtilities.TimeManager.date"><code>ClimaUtilities.TimeManager.date</code></a>, which respectively return the time as Float64 number of seconds and the associated <code>DateTime</code>.</p><p>If you want to support <code>AbstractFloat</code>s and <code>ITime</code>s, some useful functions are <code>float</code> (which returns the number of seconds as a Float64), <code>zero</code>, <code>one</code>, and <code>oneunit</code>. The difference between <code>one</code> and <code>oneunit</code> is that the latter returns a <code>ITime</code> type, while the former returns a number. This is not what happens with <code>zero</code>, which returns an <code>ITime</code>.</p><p>You might have the temptation to just sprinkle <code>float</code> everywhere to transition your code to using <code>ITime</code>s. Resist to this temptation because it might defy the purpose of using integer times in the first place.</p><p>For typical codes and simulation, we recommend only setting <code>t_start</code> and <code>t_end</code> with a <code>epoch</code>: the <code>epoch</code> will be propagated naturally to all the other times involved in the calculations.</p><p>Regarding the question on what <code>period</code> to use: if there are natural periods (e.g., you are dealing with an hourly diagnostic variable), use it, otherwise you can stick with the default. The <code>period</code> can always be changed by setting it in <code>t_start</code> and <code>t_end</code>.</p><p>We provide a constructor from floating point numbers to assist you in transitioning your package to using <code>ITime</code>s. This constructor guesses and uses the largest period that can be used to properly represent the data.</p><pre><code class="language-julia hljs">ITime(60.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0 minute [counter = 1, period = 1 minute]</code></pre><p>Beside the rounding which can lead to different results compared to using floats, the other change can come from using <code>float</code> to convert an ITime to a floating point type. At the moment, <code>float(t::ITime)</code> returns a <code>Float64</code> which can cause changes if the model is ran with Float32 instead of Float64.</p><div class="admonition is-info"><header class="admonition-header">Compatibility with ClimaTimeSteppers</header><div class="admonition-body"><p>Only IMEXAlgorithms and SSPKnoth in ClimaTimeSteppers are compatible with ITime.</p></div></div><h3 id="Common-problems"><a class="docs-heading-anchor" href="#Common-problems">Common problems</a><a id="Common-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Common-problems" title="Permalink"></a></h3><h4 id="How-do-I-make-several-ITimes-have-the-same-type?"><a class="docs-heading-anchor" href="#How-do-I-make-several-ITimes-have-the-same-type?">How do I make several <code>ITime</code>s have the same type?</a><a id="How-do-I-make-several-ITimes-have-the-same-type?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-make-several-ITimes-have-the-same-type?" title="Permalink"></a></h4><p>One can use <code>promote</code> to make all the variables have the same type. See the example below of making <code>t0</code> and <code>tf</code> have the same type.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t0 = ITime(0.25; epoch = DateTime(2012, 12, 21))</code><code class="nohighlight hljs ansi" style="display:block;">250.0 milliseconds (2012-12-21T00:00:00.250) [counter = 250, period = 1 millisecond, epoch = 2012-12-21T00:00:00]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tf = ITime(10; period = Hour(1), epoch = DateTime(2012, 12, 21))</code><code class="nohighlight hljs ansi" style="display:block;">10.0 hours (2012-12-21T10:00:00) [counter = 10, period = 1 hour, epoch = 2012-12-21T00:00:00]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(t0) == typeof(tf)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t0_same_type, tf_same_type = promote(t0, tf)</code><code class="nohighlight hljs ansi" style="display:block;">(250.0 milliseconds (2012-12-21T00:00:00.250) [counter = 250, period = 1 millisecond, epoch = 2012-12-21T00:00:00], 3.6e7 milliseconds (2012-12-21T10:00:00) [counter = 36000000, period = 1 millisecond, epoch = 2012-12-21T00:00:00])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(t0_same_type) == typeof(tf_same_type)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Similarly, one can also make <code>ITime</code>s in an array have the same type with a bit more effort.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; itime_array = [t0, tf]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ClimaUtilities.TimeManager.ITime{Int64, DT, Dates.DateTime} where DT}:
 250.0 milliseconds (2012-12-21T00:00:00.250) [counter = 250, period = 1 millisecond, epoch = 2012-12-21T00:00:00]
 10.0 hours (2012-12-21T10:00:00) [counter = 10, period = 1 hour, epoch = 2012-12-21T00:00:00]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eltype(itime_array)</code><code class="nohighlight hljs ansi" style="display:block;">ClimaUtilities.TimeManager.ITime{Int64, DT, Dates.DateTime} where DT</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; same_type_itime_arr = [promote(itime_array...)...]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ClimaUtilities.TimeManager.ITime{Int64, Dates.Millisecond, Dates.DateTime}}:
 250.0 milliseconds (2012-12-21T00:00:00.250) [counter = 250, period = 1 millisecond, epoch = 2012-12-21T00:00:00]
 3.6e7 milliseconds (2012-12-21T10:00:00) [counter = 36000000, period = 1 millisecond, epoch = 2012-12-21T00:00:00]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eltype(same_type_itime_arr)</code><code class="nohighlight hljs ansi" style="display:block;">ClimaUtilities.TimeManager.ITime{Int64, Dates.Millisecond, Dates.DateTime}</code></pre><h4 id="How-do-I-multiply-by-a-number-by-an-ITime?"><a class="docs-heading-anchor" href="#How-do-I-multiply-by-a-number-by-an-ITime?">How do I multiply by a number by an ITime?</a><a id="How-do-I-multiply-by-a-number-by-an-ITime?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-multiply-by-a-number-by-an-ITime?" title="Permalink"></a></h4><p>One can use <code>float</code> to cast the <code>ITime</code> into a floating point number representing the number of seconds since the epoch. Casting to a floating point number is okay as long as the floating point number is not used to keep track of time of the simulation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = ITime(1, period = Minute(1), epoch = DateTime(2010))</code><code class="nohighlight hljs ansi" style="display:block;">1.0 minute (2010-01-01T00:01:00) [counter = 1, period = 1 minute, epoch = 2010-01-01T00:00:00]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 0.1 * float(t) # 6 seconds</code><code class="nohighlight hljs ansi" style="display:block;">6.0</code></pre><p>For more information, see the section <a href="#Dealing-with-times-that-cannot-be-represented">Dealing with times that cannot be represented</a>.</p><h2 id="Developer-notes"><a class="docs-heading-anchor" href="#Developer-notes">Developer notes</a><a id="Developer-notes-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-notes" title="Permalink"></a></h2><h3 id="Why-not-use-Dates-directly?"><a class="docs-heading-anchor" href="#Why-not-use-Dates-directly?">Why not use <code>Dates</code> directly?</a><a id="Why-not-use-Dates-directly?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-not-use-Dates-directly?" title="Permalink"></a></h3><p>Periods in Julia&#39;s <code>Dates</code> are also implemented as integer counters attached to a type that encode its units. So why not using them directly?</p><p>There are a few reasons why <code>ITime</code> is preferred over Julia&#39;s <code>Dates</code>:</p><ul><li><code>Dates</code> do not support fractional intervals, which are needed for the timestepping loop;</li><li><code>Dates</code> only support the Gregorian calendar. <code>ITime</code> provides an abstraction layer that will allow us to support other calendars without changing packages;</li><li><code>Dates</code> only allow the given periods, but it often natural to pick the simulation timestep as <code>period</code>;</li><li>Julia&#39;s <code>Dates</code> are not necessarily faster or better and, being part of the standard library, means that it is hard to improve them.</li></ul><h3 id="Why-not-support-Rational?"><a class="docs-heading-anchor" href="#Why-not-support-Rational?">Why not support <code>Rational</code>?</a><a id="Why-not-support-Rational?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-not-support-Rational?" title="Permalink"></a></h3><p>Handling the case when the counter is rational introduces more complexity than necessary. For instance, it is unclear how to handle the case when a float is not perfectly representable as a rational number. This case comes up when examining the time stepping stages of ARS343 in ClimaTimeSteppers. In particular, the value <span>$\gamma$</span> is the middle root of the polynomial <span>$6x^3 - 18x^2 + 9x - 1 = 0$</span> and irrational. One could approximate <span>$\gamma$</span> as a rational number, but large integers for the numerator and denominator are needed to approximate <span>$\gamma$</span> to high accuracy. For example, <span>$\gamma$</span> approximated as a rational number with tolerance within machine epsilon of <code>Float64</code> is <code>19126397//43881317</code>. This could lead to overflowing in either the numerator or denominator as <span>$\gamma$</span> propagates through the code. Hence, rational numbers are not considered for this reason.</p><h2 id="TimeManager-API"><a class="docs-heading-anchor" href="#TimeManager-API">TimeManager API</a><a id="TimeManager-API-1"></a><a class="docs-heading-anchor-permalink" href="#TimeManager-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeManager.ITime" href="#ClimaUtilities.TimeManager.ITime"><code>ClimaUtilities.TimeManager.ITime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ITime (&quot;Integer Time&quot;)</code></pre><p><code>ITime</code> is an integer (quantized) time.</p><p><code>ITime</code> can be thought of as counting clock cycles (<code>counter</code>), with each tick having a fixed duration (<code>period</code>).</p><p>Another way to think about this is that this is time with units.</p><p>This type is currently using Dates, but one of the design goals is to try to be as agnostic as possible with respect to this so that in the future in will be possible to use a different calendar.</p><p>When using Dates, the minimum unit of time that can be represented is 1 nanosecond. The maximum unit of time is determined by the maximum integer number that can be represented.</p><p>Overflow occurs at <code>68 year * (1 Second / dt)</code> for Int32 and <code>300 gigayear * (1 Second / dt)</code> for Int64.</p><p><strong>Fields</strong></p><ul><li><code>counter::INT</code>: The number of clock cycles.</li><li><code>period::DT</code>: The duration of each cycle.</li><li><code>epoch::EPOCH</code>: An optional start date.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeManager.ITime-Tuple{Union{Integer, Rational}}" href="#ClimaUtilities.TimeManager.ITime-Tuple{Union{Integer, Rational}}"><code>ClimaUtilities.TimeManager.ITime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ITime(t; epoch = nothing)</code></pre><p>Construct an <code>ITime</code> from a number <code>t</code> representing a time interval.</p><p>The function attempts to find a <code>Dates.FixedPeriod</code> such that <code>t</code> can be represented as an integer multiple of that period.</p><p>If <code>t</code> is approximately zero, it defaults to a period of 1 second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L170-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeManager.ITime-Tuple{Any}" href="#ClimaUtilities.TimeManager.ITime-Tuple{Any}"><code>ClimaUtilities.TimeManager.ITime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ITime(t; epoch = nothing)</code></pre><p>Construct an <code>ITime</code> from a number <code>t</code> representing a time interval.</p><p>The function attempts to find a <code>Dates.FixedPeriod</code> such that <code>t</code> can be represented as an integer multiple of that period.</p><p>If <code>t</code> is approximately zero, it defaults to a period of 1 second.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L170-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeManager.seconds" href="#ClimaUtilities.TimeManager.seconds"><code>ClimaUtilities.TimeManager.seconds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seconds(t::ITime)</code></pre><p>Return the time represented by <code>t</code> in seconds, as a floating-point number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeManager.counter" href="#ClimaUtilities.TimeManager.counter"><code>ClimaUtilities.TimeManager.counter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">counter(t::ITime)</code></pre><p>Return the counter of the <code>ITime</code> <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeManager.period" href="#ClimaUtilities.TimeManager.period"><code>ClimaUtilities.TimeManager.period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">period(t::ITime)</code></pre><p>Return the period of the <code>ITime</code> <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeManager.epoch" href="#ClimaUtilities.TimeManager.epoch"><code>ClimaUtilities.TimeManager.epoch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">epoch(t::ITime)</code></pre><p>Return the start date of the <code>ITime</code> <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeManager.date" href="#ClimaUtilities.TimeManager.date"><code>ClimaUtilities.TimeManager.date</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">date(t::ITime)</code></pre><p>Return the date associated with <code>t</code>. If the time is fractional, round it to millisecond.</p><p>For this to work, <code>t</code> has to have a <code>epoch</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote-Tuple{Vararg{ClimaUtilities.TimeManager.ITime}}" href="#Base.promote-Tuple{Vararg{ClimaUtilities.TimeManager.ITime}}"><code>Base.promote</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote(ts::ITime...)</code></pre><p>Promote a tuple of <code>ITime</code> instances to a common type.</p><p>This function determines a common <code>epoch</code> and <code>period</code> for all the input <code>ITime</code> instances and returns a tuple of new <code>ITime</code> instances with the common type.  It throws an error if the start dates are different.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L228-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.::-Tuple{ClimaUtilities.TimeManager.ITime, ClimaUtilities.TimeManager.ITime, ClimaUtilities.TimeManager.ITime}" href="#Base.::-Tuple{ClimaUtilities.TimeManager.ITime, ClimaUtilities.TimeManager.ITime, ClimaUtilities.TimeManager.ITime}"><code>Base.::</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:(:)(start::ITime, step::ITime, stop::ITime)</code></pre><p>Range operator. <code>start:step:stop</code> constructs a range from start to stop with a step size equal to step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L325-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mod-Tuple{ClimaUtilities.TimeManager.ITime, ClimaUtilities.TimeManager.ITime}" href="#Base.mod-Tuple{ClimaUtilities.TimeManager.ITime, ClimaUtilities.TimeManager.ITime}"><code>Base.mod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.mod(x::ITime, y::ITime)</code></pre><p>Return the counter of <code>x</code> modulo counter of <code>y</code> after promote <code>x</code> and <code>y</code> to the same period and epoch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L340-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iszero-Tuple{ClimaUtilities.TimeManager.ITime}" href="#Base.iszero-Tuple{ClimaUtilities.TimeManager.ITime}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iszero(x::ITime)</code></pre><p>Return <code>true</code> if the counter of <code>x</code> is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L362-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{ClimaUtilities.TimeManager.ITime}" href="#Base.length-Tuple{ClimaUtilities.TimeManager.ITime}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.length(x::ITime)</code></pre><p>Return the length of an ITime which is always one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L371-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.float-Tuple{T} where T&lt;:ClimaUtilities.TimeManager.ITime" href="#Base.float-Tuple{T} where T&lt;:ClimaUtilities.TimeManager.ITime"><code>Base.float</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">float(t::ITime)</code></pre><p>Convert an <code>ITime</code> to a floating-point number representing the time in seconds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L405-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.one-Tuple{T} where T&lt;:ClimaUtilities.TimeManager.ITime" href="#Base.one-Tuple{T} where T&lt;:ClimaUtilities.TimeManager.ITime"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.one(t::T) where {T &lt;: ITime}</code></pre><p>Return the multiplicative identity for an <code>ITime</code> which is <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L381-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.oneunit-Tuple{T} where T&lt;:ClimaUtilities.TimeManager.ITime" href="#Base.oneunit-Tuple{T} where T&lt;:ClimaUtilities.TimeManager.ITime"><code>Base.oneunit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.oneunit(t::T) where {T &lt;: ITime}</code></pre><p>Return <code>ITime(1, period(t), epoch(t))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L388-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zero-Tuple{T} where T&lt;:ClimaUtilities.TimeManager.ITime" href="#Base.zero-Tuple{T} where T&lt;:ClimaUtilities.TimeManager.ITime"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.zero(t::T) where {T &lt;: ITime}</code></pre><p>Return the additive identity element for an <code>ITime</code> which is <code>ITime(0, period(t), epoch(t))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L396-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{ClimaUtilities.TimeManager.ITime, AbstractFloat}" href="#Base.:*-Tuple{ClimaUtilities.TimeManager.ITime, AbstractFloat}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(t::ITime, a::AbstractFloat)</code></pre><p>Multiplication between an ITime and float return an <code>ITime</code> whose counter is <code>round(a * counter(t))</code>, the same period as <code>t</code>, and the same epoch as <code>t</code> if it exists. The float <code>a</code> can only be between 0 and 1.</p><p>This function should only be used when subdividing time is necessary (e.g. time stepping stages in ClimaTimeSteppers). In most cases, it is preferable to convert <code>t</code> into a float if multiplication by a float is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/bf0863ac3549d38820a2ea688aa3597614241410/src/ITime.jl#L281-L291">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../outputpathgenerator/">« OutputPathGenerator</a><a class="docs-footer-nextpage" href="../faqs/">Frequently Asked Questions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 15 July 2025 17:50">Tuesday 15 July 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
