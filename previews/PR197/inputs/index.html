<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Space and Time Inputs · ClimaUtilities.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ClimaUtilities.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaUtilities.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../datastructures/">Data Structures</a></li><li><a class="tocitem" href="../climaartifacts/">ClimaArtifacts</a></li><li class="is-active"><a class="tocitem" href>Space and Time Inputs</a><ul class="internal"><li><a class="tocitem" href="#timevaryinginput"><span><code>TimeVaryingInputs</code></span></a></li><li><a class="tocitem" href="#spacevaryinginput"><span><code>SpaceVaryingInputs</code></span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../filereaders/">FileReaders</a></li><li><a class="tocitem" href="../datahandling/">DataHandling</a></li><li><a class="tocitem" href="../regridders/">Regridders</a></li><li><a class="tocitem" href="../onlinelogging/">OnlineLogging</a></li><li><a class="tocitem" href="../outputpathgenerator/">OutputPathGenerator</a></li><li><a class="tocitem" href="../timemanager/">TimeManager</a></li><li><a class="tocitem" href="../faqs/">Frequently Asked Questions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Space and Time Inputs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Space and Time Inputs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaUtilities.jl/blob/main/docs/src/inputs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SpaceVaringInputs-and-TimeVaryingInputs"><a class="docs-heading-anchor" href="#SpaceVaringInputs-and-TimeVaryingInputs"><code>SpaceVaringInputs</code> and <code>TimeVaryingInputs</code></a><a id="SpaceVaringInputs-and-TimeVaryingInputs-1"></a><a class="docs-heading-anchor-permalink" href="#SpaceVaringInputs-and-TimeVaryingInputs" title="Permalink"></a></h1><p>Most models require external inputs to work. Examples of inputs are an analytic function that prescribes the sea-surface temperature in time, or a file that describes the types of plants on the surface of the globe. The <code>SpaceVaringInputs</code> and <code>TimeVaryingInputs</code> modules provide a unified infrastructure to handle all these cases.</p><h2 id="timevaryinginput"><a class="docs-heading-anchor" href="#timevaryinginput"><code>TimeVaryingInputs</code></a><a id="timevaryinginput-1"></a><a class="docs-heading-anchor-permalink" href="#timevaryinginput" title="Permalink"></a></h2><blockquote><p>This extension is loaded when loading <code>ClimaCore</code> is loaded. In addition to this, if NetCDF files are used, <code>NCDatasets</code> has to be loaded too. Finally, a <code>Regridder</code> is needed (which might require importing additional packages).</p></blockquote><p>A <code>TimeVaryingInput</code> is an object that knows how to fill a <code>ClimaCore</code> <code>Field</code> at a given simulation time <code>t</code>. <code>TimeVaryingInputs</code> can be constructed in a variety of ways, from using analytic functions, to NetCDF data. They expose one interface, <code>evaluate!(dest_field, tv, time)</code>, which can be used by model developers to update their <code>Field</code>s.</p><p>This example shows that <code>TimeVaryingInput</code> can take different types of inputs and be used with a single interface (<code>evaluate!</code>). In all of this, <code>TimeVaryingInput</code>s internally handle all the complexity related to reading files (using <a href="../filereaders/#file_reader_module"><code>FileReaders</code></a>), dealing with parallelism and GPUs, regridding onto the computational domains (using <a href="../regridders/#regridder_module"><code>Regridders</code></a> and <a href="../datahandling/#datahandling_module"><code>DataHandling</code></a>), and so on.</p><p><code>TimeVaryingInputs</code> support:</p><ul><li>analytic functions of time;</li><li>pairs of 1D arrays (e.g., for <code>PointSpaces</code> or constant fields);</li><li>2/3D NetCDF files (including composing multiple variables from one or more files into one variable);</li><li>linear interpolation in time (default), nearest neighbors, and &quot;period filling&quot;;</li><li>boundary conditions and repeating periodic data.</li></ul><p>It is possible to pass down keyword arguments to underlying constructors in the <code>Regridder</code> with the <code>regridder_kwargs</code> and <code>file_reader_kwargs</code>. These have to be a named tuple or a dictionary that maps <code>Symbol</code>s to values.</p><h3 id="NetCDF-file-inputs"><a class="docs-heading-anchor" href="#NetCDF-file-inputs">NetCDF file inputs</a><a id="NetCDF-file-inputs-1"></a><a class="docs-heading-anchor-permalink" href="#NetCDF-file-inputs" title="Permalink"></a></h3><p>2D or 3D NetCDF files can be provided as inputs using <code>TimeVaryingInputs</code>. This could be a single variable provided in a single file, multiple variables provided in a single file, or multiple variables each coming from a unique file. When using multiple variables, a composing function must be provided as well, which will be used to combine the input variables into one data variable that is ultimately stored in the <code>TimeVaryingInput</code>. In this case, the order of variables provided in <code>varnames</code> determines the order of the arguments passed to the composing function.</p><p>Note that if a non-identity pre-processing function is provided as part of <code>file_reader_kwargs</code>, it will be applied to each input variable before they are composed. All input variables to be composed together must have the same spatial and temporal dimensions.</p><p>Composing multiple input variables is currently only supported with the <a href="../regridders/#interp_regridder"><code>InterpolationsRegridder</code></a>, not with <a href="../regridders/#tempest_regridder"><code>TempestRegridder</code></a>. The regridding is applied after the pre-processing and composing.</p><p>Composing multiple input variables in one <code>Input</code> is also possible with a <code>SpaceVaryingInput</code>, and everything mentioned here applies in that case.</p><h4 id="Example:-NetCDF-file-input-with-multiple-input-variables"><a class="docs-heading-anchor" href="#Example:-NetCDF-file-input-with-multiple-input-variables">Example: NetCDF file input with multiple input variables</a><a id="Example:-NetCDF-file-input-with-multiple-input-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-NetCDF-file-input-with-multiple-input-variables" title="Permalink"></a></h4><p>Suppose that the input NetCDF file <code>era5_example.nc</code> contains two variables <code>u</code> and <code>v</code>, and we care about their sum <code>u + v</code> but not their individual values. We can provide a pointwise composing function to perform the sum, along with the <a href="../regridders/#interp_regridder"><code>InterpolationsRegridder</code></a> to produce the data we want, <code>u + v</code>. The <code>preprocess_func</code> passed in <code>file_reader_kwargs</code> will be applied to <code>u</code> and to <code>v</code> individually, before the composing function is applied. The regridding is applied after the composing function. <code>u</code> and <code>v</code> could also come from separate NetCDF files, but they must still have the same spatial and temporal dimensions.</p><pre><code class="language-julia hljs"># Define the pointwise composing function we want, a simple sum in this case
compose_function = (x, y) -&gt; x + y
# Define pre-processing function to convert units of input
unit_conversion_func = (data) -&gt; 1000 * data

timevaryinginput = TimeVaryingInputs.TimeVaryingInput(&quot;era5_example.nc&quot;,
                                        [&quot;u&quot;, &quot;v&quot;],
                                        target_space,
                                        start_date = Dates.DateTime(2000, 1, 1),
                                        regridder_type = :InterpolationsRegridder,
                                        file_reader_kwargs = (; preprocess_func = unit_conversion_func),
                                        compose_function)</code></pre><p>The same arguments (excluding <code>start_date</code>) could be passed to a <code>SpaceVaryingInput</code> to compose multiple input variables with that type.</p><h4 id="Example:-Data-split-across-multiple-NetCDF-files"><a class="docs-heading-anchor" href="#Example:-Data-split-across-multiple-NetCDF-files">Example: Data split across multiple NetCDF files</a><a id="Example:-Data-split-across-multiple-NetCDF-files-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Data-split-across-multiple-NetCDF-files" title="Permalink"></a></h4><p>Often, large datasets come chunked, meaning that the data is split across multiple files with each file containing only a subset of the time interval. <code>TimeVaryingInput</code>s know to combine data across multiple files as it were provided in a single file. To do use this feature, just pass the list of file paths. While it is not required for the files to be in order, it is good practice to pass them in ascending order by time.</p><p>For example:</p><pre><code class="language-julia hljs">timevaryinginput = TimeVaryingInputs.TimeVaryingInput([&quot;era5_1980.nc&quot;, &quot;era5_1981.nc&quot;],
                                                       &quot;u&quot;,
                                                       target_space,
                                                       start_date = Dates.DateTime(1980, 1, 1),
                                                       regridder_type = :InterpolationsRegridder
                                                       )</code></pre><p>This capability is only available for the <code>InterpolationsRegridder</code>.</p><p>Read more about this feature in the page about <a href="../datahandling/#datahandling_module"><code>DataHandler</code></a>.</p><h3 id="Extrapolation-boundary-conditions"><a class="docs-heading-anchor" href="#Extrapolation-boundary-conditions">Extrapolation boundary conditions</a><a id="Extrapolation-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Extrapolation-boundary-conditions" title="Permalink"></a></h3><p><code>TimeVaryingInput</code>s can have multiple boundary conditions for extrapolation. By default, the <code>Throw</code> condition is used, meaning that interpolating onto a point that is outside the range of definition of the data is not allowed. Other boundary conditions are allowed. With the <code>Flat</code> boundary condition, when interpolating outside of the range of definition, return the value of the of closest boundary is used instead.</p><p>To set these boundary conditions, construct the relevant method passing the argument. For example, to combine <code>NearestNeighbor</code> with <code>Flat</code>:</p><pre><code class="language-julia hljs">import ClimaUtilities: TimeVaryingInputs

method = TimeVaryingInputs.NearestNeighbor(TimeVaryingInputs.Flat())</code></pre><p>A boundary condition that is often useful is <code>PeriodicCalendar</code>, which repeats the data over and over.</p><p>In general <code>PeriodicCalendar</code> takes two inputs: the <code>period</code> and <code>repeat_date</code>. The repeat period is a <code>Dates.DatePeriod</code> (e.g., <code>Dates.Year(1)</code>) that defines the duration of the period that has to be repeated. The <code>repeat_date</code> defines what date range needs to be repeated. For example, if <code>period = Dates.Month(1)</code> and <code>repeat_date = Dates.Date(1993, 11)</code>, November 1993 will be repeated.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>While <code>PeriodicCalendar</code> is described as an extrapolation boundary condition, it may also change the data used during the time period where data is available. For example, take the case where data from 2000 to 2020 is available, and we have <code>period = Dates.Year(1)</code> and <code>repeat_date = Dates.Date(2000)</code>. The data from 2000 will be repeated for <em>every year of the simulation</em> - outside of the 2000-2020 range where data is available, but also for every year within that range. In this sense, <code>PeriodicCalendar</code> is not a true boundary condition only.</p></div></div><p>The two inputs are not required. When they are not provided, <code>ClimaUtilities</code> will assume that the input data constitutes one period and use that. For example, if the data is defined from <code>t0</code> to <code>t1</code> (e.g., 1 and 5), interpolating over <code>t &gt; t1</code> (e.g., 7) is equivalent to interpolating to <code>t*</code> where <code>t*</code> is the modulus of <code>t</code> and the range (3 in this case). In this case, <code>PeriodicCalendar</code> requires the data to be uniformly spaced in time. To enable this boundary condition, pass <code>LinearInterpolation(PeriodicCalendar())</code> to the <code>TimeVaryingInput</code> (or <code>NearestNeighbor(PeriodicCalendar())</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This <code>PeriodicCalendar</code> is different from what you might be used to, where the identification is <code>t1 = t0</code>. Here, we identify <code>t1 + dt = t0</code>. This is so that we can use it to repeat calendar data.</p></div></div><h3 id="LinearPeriodFillingInterpolation"><a class="docs-heading-anchor" href="#LinearPeriodFillingInterpolation"><code>LinearPeriodFillingInterpolation</code></a><a id="LinearPeriodFillingInterpolation-1"></a><a class="docs-heading-anchor-permalink" href="#LinearPeriodFillingInterpolation" title="Permalink"></a></h3><p>Often, data is not available at the frequency we would like it to be. For example, we might have hourly data for a given quantity but only on the 15th of the month. Performing linear interpolation with data with this type of gap is typically not accurate. Consider the example of a quantity with a diurnal cycle but measured only once a month. If we were to blindly perform linear interpolation, we would find that the diurnal cycle is completely removed for every day of the month but the 15th. This is because we would interpolate the last point for the day of a given month, with the first for the following.</p><p><code>LinearPeriodFillingInterpolation</code> is an interpolation method that solves this problem by preserving periodic structures. This is accomplished by performing linear interpolation across corresponding periods (in the case of the day, across corresponding hours of different days). For more information, please refer to the docstring.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Let <code>target_space</code> be the computational domain (a <code>ClimaCore</code> <code>Space</code>) and <code>cesm_albedo.nc</code> a NetCDF file containing albedo data as a function of time in a variable named <code>alb</code>.</p><pre><code class="language-julia hljs">import ClimaUtilities: TimeVaryingInputs
import ClimaCore
import NCDatasets
import ClimaCoreTempestRemap
# Loading ClimaCore, NCDatasets, ClimaCoreTempestRemap loads the extensions we need

function evolve_model(albedo_tv, albedo_field)
    new_t = t + dt
    # First, we update the albedo to the new time
    evaluate!(albedo_field, albedo_tv, new_t)
    # Now we can do all the operations we want we albedo_filed
    # rhs = ...
end

# Let us prepare an empty Field that will contain the albedo
albedo_field = zero(target_space)

# If the albedo is an analytic function of time
albedo_tv_an = TimeVaryingInput((t) -&gt; 0.5)

# If the albedo comes from data

# start_date is the calendar date at the beginning of our simulation
start_date = Dates.DateTime(2000, 1, 1)
albedo_tv = TimeVaryingInputs.TimeVaryingInput(&quot;cesem_albedo.nc&quot;, &quot;alb&quot;, target_space;
                                               start_date, regridder_kwargs = (; regrid_dir = &quot;/tmp&quot;))
# When using data from files, the data is automatically interpolated to the correct
# time

# In either cases, we can always call evolve_model(albedo_tv, albedo_field), so
# model developers do not have to worry about anything :)</code></pre><p>As seen in this example, <code>Inputs</code> can take keyword arguments and pass them down to other constructors. This often used to preprocess files that are being read (most commonly to change units). For example, if we want to multiply the albedo by a factor of 100, we would change <code>albedo_tv</code> with</p><pre><code class="language-julia hljs">albedo_tv = TimeVaryingInputs.TimeVaryingInput(&quot;cesem_albedo.nc&quot;, &quot;alb&quot;, target_space;
                                               start_date, regridder_kwargs = (; regrid_dir = &quot;/tmp&quot;),
                                               file_reader_kwargs = (; preprocess_func = (x) -&gt; 100x))</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In this example we used the <a href="../regridders/#tempest_regridder"><code>TempestRegridder</code></a>. This is not the best choice in most cases because the <a href="../regridders/#tempest_regridder"><code>TempestRegridder</code></a> is slower, and not well-compatible with MPI and GPUs (<code>ClimaUtilities</code> implements workarounds for this, so the code would still work). <a href="../regridders/#interp_regridder"><code>InterpolationsRegridder</code></a> should be preferred, unless there is a strict requirement of conservation: while <a href="../regridders/#tempest_regridder"><code>TempestRegridder</code></a> is guaranteed to conserve various properties, <a href="../regridders/#interp_regridder"><code>InterpolationsRegridder</code></a> is not.</p></div></div><h2 id="spacevaryinginput"><a class="docs-heading-anchor" href="#spacevaryinginput"><code>SpaceVaryingInputs</code></a><a id="spacevaryinginput-1"></a><a class="docs-heading-anchor-permalink" href="#spacevaryinginput" title="Permalink"></a></h2><blockquote><p>This extension is loaded when loading <code>ClimaCore</code> is loaded. In addition to this, if NetCDF files are used, <code>NCDatasets</code> has to be loaded too. Finally, a <code>Regridder</code> is needed (which might require importing additional packages).</p></blockquote><p><code>SpaceVaryingInput</code>s uses the same building blocks as <code>TimeVaryingInput</code> (chiefly the <a href="../datahandling/#datahandling_module"><code>DataHandling</code></a> datahandling_module) to construct a <code>Field</code> from different sources.</p><p><code>SpaceVaryingInputs</code> support:</p><ul><li>analytic functions of coordinates;</li><li>pairs of 1D arrays (for columns);</li><li>2/3D NetCDF files (including composing multiple variables from one or more files into one variable).</li></ul><p>In some ways, a <code>SpaceVaryingInput</code> can be thought as an alternative constructor for a <code>ClimaCore</code> <code>Field</code>.</p><p>It is possible to pass down keyword arguments to underlying constructors in the <code>Regridder</code> with the <code>regridder_kwargs</code> and <code>file_reader_kwargs</code>. These have to be a named tuple or a dictionary that maps <code>Symbol</code>s to values.</p><p><code>SpaceVaryingInputs</code> support reading individual input variables from NetCDF files, as well as composing multiple input variables into one <code>SpaceVaryingInput</code>. See the <a href="#timevaryinginput"><code>TimeVaryingInput</code></a> &quot;NetCDF file inputs&quot; section for more information about this feature.</p><h3 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h3><p>Let <code>target_space</code> be a <code>ClimaCore</code> <code>Space</code> where we want the <code>Field</code> to be defined on and <code>cesm_albedo.nc</code> a NetCDF file containing albedo data as a time in a variable named <code>alb</code>.</p><pre><code class="language-julia hljs">import ClimaUtilities: SpaceVaryingInputs
import ClimaCore
import NCDatasets
import ClimaCoreTempestRemap
# Loading ClimaCore, NCDatasets, ClimaCoreTempestRemap loads the extensions we need

# Albedo as an analytic function of lat and lon
albedo_latlon_fun = (coord) -&gt; 0.5 * coord.long * coord.lat

albedo = SpaceVaryingInputs.SpaceVaryingInput(albedo_latlon_fun, target_space)

albedo_from_file = SpaceVaryingInputs.SpaceVaryingInput(&quot;cesm_albedo.nc&quot;, &quot;alb&quot;, target_space, regridder_kwargs = (; regrid_dir = &quot;/tmp&quot;))</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.SpaceVaryingInputs.SpaceVaryingInput" href="#ClimaUtilities.SpaceVaryingInputs.SpaceVaryingInput"><code>ClimaUtilities.SpaceVaryingInputs.SpaceVaryingInput</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SpaceVaryingInput(data_function::Function, space::ClimaCore.Spaces.AbstractSpace)</code></pre><p>Returns the parameter field to be used in the model; appropriate when a parameter is defined using a function of the coordinates of the space.</p><p>Pass the `<code>data&quot; as a function</code>data_function` which takes coordinates as arguments, and  the ClimaCore space of the model simulation.</p><p>This returns a scalar field. Note that data_function is broadcasted over the coordinate field. Internally, inside your function, this must be unpacked (coords.lat, coords.lon, e.g.) for use of the coordinate values directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/ext/SpaceVaryingInputsExt.jl#L14-L27">source</a></section><section><div><pre><code class="nohighlight hljs">function SpaceVaryingInput(
    data_z::AbstractArray,
    data_values::AbstractArray,
    space::S,
) where {S &lt;: ClimaCore.Spaces.CenterFiniteDifferenceSpace}</code></pre><p>Given a set of depths <code>data_z</code> and the observed values <code>data_values</code> at those depths, create an interpolated field of values at each value of z in the model grid - defined implicitly by <code>space</code>.</p><p>Returns a ClimaCore.Fields.Field of scalars.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/ext/SpaceVaryingInputsExt.jl#L38-L50">source</a></section><section><div><pre><code class="nohighlight hljs">SpaceVaryingInputs.SpaceVaryingInput(
    data_z::AbstractArray,
    data_values::NamedTuple,
    space::S,
    dest_type::Type{DT},
) where {
    S &lt;: ClimaCore.Spaces.CenterFiniteDifferenceSpace,
    DT,
}</code></pre><p>Returns a field of parameter structs to be used in the model; appropriate when the parameter struct values vary in depth; the <code>dest_type</code> argument is the struct type - we assumed that your struct as a constructor which accepts the values of its arguments by kwarg,</p><ul><li><code>data_z</code> is where the measured values were obtained,</li><li><code>data_values</code> is a NamedTuple with keys equal to the argument names</li></ul><p>of the struct, and with values equal to an array of measured values,</p><ul><li><code>space</code> defines the model grid.</li></ul><p>As an example, we can create a field of vanGenuchten structs as follows. This struct requires two parameters, <code>α</code> and <code>n</code>. Let&#39;s assume that we have measurements of these as a function of depth at the locations given by <code>data_z</code>, called <code>data_α</code> and <code>data_n</code>. Then we can write <code>vG_field = SpaceVaryingInput(data_z, (;α = data_α, n = data_n), space, vanGenuchten{Float32})</code>. Under the hood, at each point in the model grid, we will create <code>vanGenuchten{Float32}(;α = interp_α, n = interp_n)</code>, where <code>interp</code> indicates the interpolated value at the model depth.</p><p>Returns a ClimaCore.Fields.Field of type DT.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/ext/SpaceVaryingInputsExt.jl#L72-L104">source</a></section><section><div><pre><code class="nohighlight hljs">SpaceVaryingInput(data_handler::DataHandler)
SpaceVaryingInput(file_paths::Union{AbstractString, AbstractArray{String}},
                  varnames::Union{AbstractString, AbstractArray{String}},
                  target_space::Spaces.AbstractSpace;
                  regridder_type::Symbol,
                  regridder_kwargs = (),
                  file_reader_kwargs = ())</code></pre><p>Returns the parameter field to be used in the model; appropriate when a parameter is defined on the surface of the Earth.</p><p>Returns a ClimaCore.Fields.Field of scalars; analogous to the 1D case which also returns a ClimaCore.Fields.Field of scalars.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/ext/SpaceVaryingInputsExt.jl#L127-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeVaryingInputs.AbstractInterpolationMethod" href="#ClimaUtilities.TimeVaryingInputs.AbstractInterpolationMethod"><code>ClimaUtilities.TimeVaryingInputs.AbstractInterpolationMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractInterpolationMethod</code></pre><p>Defines how to perform interpolation.</p><p>Not all the TimeVaryingInputs support all the interpolation methods (e.g., no interpolation methods are supported when the given function is analytic).</p><p><code>AbstractInterpolationMethod</code>s have to implement a <code>extrapolation_bc</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/src/TimeVaryingInputs.jl#L49-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeVaryingInputs.AbstractInterpolationBoundaryMethod" href="#ClimaUtilities.TimeVaryingInputs.AbstractInterpolationBoundaryMethod"><code>ClimaUtilities.TimeVaryingInputs.AbstractInterpolationBoundaryMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractInterpolationBoundaryMethod</code></pre><p>Defines how to handle values outside of the data boundary.</p><p>Not all the <code>AbstractInterpolationMethod</code> support all the <code>AbstractInterpolationBoundaryMethod</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/src/TimeVaryingInputs.jl#L61-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeVaryingInputs.NearestNeighbor" href="#ClimaUtilities.TimeVaryingInputs.NearestNeighbor"><code>ClimaUtilities.TimeVaryingInputs.NearestNeighbor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NearestNeighbor(extrapolation_bc::AbstractInterpolationBoundaryMethod)</code></pre><p>Return the value corresponding to the point closest to the input time.</p><p><code>extrapolation_bc</code> specifies how to deal with out of boundary values. The default value is <code>Throw</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/src/TimeVaryingInputs.jl#L205-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeVaryingInputs.LinearInterpolation" href="#ClimaUtilities.TimeVaryingInputs.LinearInterpolation"><code>ClimaUtilities.TimeVaryingInputs.LinearInterpolation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearInterpolation(extrapolation_bc::AbstractInterpolationBoundaryMethod)</code></pre><p>Perform linear interpolation between the two neighboring points.</p><p><code>extrapolation_bc</code> specifies how to deal with out of boundary values. The default value is <code>Throw</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/src/TimeVaryingInputs.jl#L222-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeVaryingInputs.Throw" href="#ClimaUtilities.TimeVaryingInputs.Throw"><code>ClimaUtilities.TimeVaryingInputs.Throw</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Throw</code></pre><p>Throw an error when interpolating outside of range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/src/TimeVaryingInputs.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeVaryingInputs.PeriodicCalendar" href="#ClimaUtilities.TimeVaryingInputs.PeriodicCalendar"><code>ClimaUtilities.TimeVaryingInputs.PeriodicCalendar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PeriodicCalendar</code></pre><p>Repeat data periodically.</p><p><code>PeriodicCalendar</code> has two modes of operation:</p><p>First, when provided with a <code>period</code> (a <code>Dates.DatePeriod</code>, e.g., <code>Dates.Month(1)</code> or <code>Dates.Year(1)</code>), assume that the provided data is repeated over that calendar period, even during dates of the simulation when other data is available. A <code>date</code> can be passed too, indicating what data to use. Only simple periods (e.g., <code>Dates.Month(1)</code>) are supported. When provided a period, a <code>repeat_date</code> is required too. This is the period of time that is repeated. For example, if <code>period = Dates.Month(1)</code> and <code>repeat_date = Dates.Date(1993, 11)</code>, November 1993 is repeated (if available in the input data).</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>In the case described above, <code>PeriodicCalendar</code> does not act as strictly a boundary condition. It rather acts as a filter on the input data, selecting only data corresponding to the given period and date and reusing this data repeatedly. This changes the data that is used during the simulation, even within the time range of the input data.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Passing a period is not supported by all the interpolators (e.g., when reading from 1D files).</p></div></div><p>Second, if no period is provided, when interpolating outside of range, restart from the beginning.</p><p>For example, if the data is defined from t0 = 0 to t1 = 10, extrapolating at t=13 is equivalent to interpolating at t=2. In practice, we identify <code>t1 + dt</code> to be <code>t0</code> again. This is different from what you might be used to for periodic boundary conditions, where the identification is <code>t1 = t0</code>.</p><p>This second mode of operation <code>PeriodicCalendar</code> requires data to be uniformly sampled in time.</p><p>If the data is defined on a single calendar year, this second mode of operation is equivalent to using the first mode with <code>period = Dates.Year</code> (same with other periods).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/src/TimeVaryingInputs.jl#L77-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeVaryingInputs.Flat" href="#ClimaUtilities.TimeVaryingInputs.Flat"><code>ClimaUtilities.TimeVaryingInputs.Flat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flat</code></pre><p>When interpolating outside of range, use the boundary value.</p><p>For example, if the data is defined from t0 = 0 to t1 = 10, extrapolating at t=13 returns the value at t1 = 10. When interpolating at t=-3, use t0 = 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/src/TimeVaryingInputs.jl#L139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeVaryingInputs.evaluate!" href="#ClimaUtilities.TimeVaryingInputs.evaluate!"><code>ClimaUtilities.TimeVaryingInputs.evaluate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate!(dest, input, time, args...; kwargs...)</code></pre><p>Evaluate the <code>input</code> at the given <code>time</code>, writing the output in-place to <code>dest</code>.</p><p>Depending on the details of <code>input</code>, this function might do I/O and communication.</p><p><strong>Extra arguments</strong></p><p><code>args</code> and <code>kwargs</code> are used only when the <code>input</code> is a non-interpolating function, e.g., an analytic one. In that case, <code>args</code> and <code>kwargs</code> are passed down to the function itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/src/TimeVaryingInputs.jl#L181-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimaUtilities.TimeVaryingInputs.extrapolation_bc" href="#ClimaUtilities.TimeVaryingInputs.extrapolation_bc"><code>ClimaUtilities.TimeVaryingInputs.extrapolation_bc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extrapolation_bc(aim::AbstractInterpolationMethod)</code></pre><p>Return the interpolation boundary conditions associated to <code>aim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/src/TimeVaryingInputs.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in" href="#Base.in"><code>Base.in</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">in(time, itp::InterpolatingTimeVaryingInput23D)</code></pre><p>Check if the given <code>time</code> is in the range of definition for <code>itp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/ext/TimeVaryingInputs0DExt.jl#L57-L61">source</a></section><section><div><pre><code class="nohighlight hljs">in(time, itp::InterpolatingTimeVaryingInput23D)</code></pre><p>Check if the given <code>time</code> is in the range of definition for <code>itp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/ext/TimeVaryingInputsExt.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.close-Tuple{ClimaUtilities.TimeVaryingInputs.AbstractTimeVaryingInput}" href="#Base.close-Tuple{ClimaUtilities.TimeVaryingInputs.AbstractTimeVaryingInput}"><code>Base.close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">close(time_varying_input::TimeVaryingInputs.AbstractTimeVaryingInput)</code></pre><p>Close files associated to the <code>time_varying_input</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/ClimaUtilities.jl/blob/4858679e2ab674116eacddd59acb30e026a44f42/ext/TimeVaryingInputsExt.jl#L432-L436">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../climaartifacts/">« ClimaArtifacts</a><a class="docs-footer-nextpage" href="../filereaders/">FileReaders »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 31 October 2025 17:21">Friday 31 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
