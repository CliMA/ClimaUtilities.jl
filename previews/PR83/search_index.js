var documenterSearchIndex = {"docs":
[{"location":"datahandling/#DataHandling","page":"DataHandling","title":"DataHandling","text":"","category":"section"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"The DataHandling module is responsible for reading data from files and resampling it onto the simulation grid.","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"This is no trivial task. Among the challenges:","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"data can be large and cannot be read all in one go and/or held in memory,\nregridding onto the simulation grid can be very expensive,\nIO can be very expensive,\nCPU/GPU communication can be a bottleneck.","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"The DataHandling takes the divide and conquer approach: the various core tasks and features and split into other independent modules (chiefly FileReaders, and Regridders). Such modules can be developed, tested, and extended independently (as long as they maintain a consistent interface). For instance, if need arises, the DataHandler can be used (almost) directly to process files with a different format from NetCDF.","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"The key struct in DataHandling is the DataHandler. The DataHandler contains a FileReader, a Regridder, and other metadata necessary to perform its operations (e.g., target ClimaCore.Space). The DataHandler can be used for static or temporal data, and exposes the following key functions:","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"regridded_snapshot(time): to obtain the regridded field at the given time.                   time has to be available in the data.\navailable_times (available_dates): to list all the times (dates) over                   which the data is defined.\nprevious_time(time/date) (next_time(time/date)): to obtain the time of the                        snapshot before the given time or date. This can be                        used to compute the interpolation weight for linear                        interpolation, or in combination with                        regridded_snapshot to read a particular snapshot","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"Most DataHandling functions take either time or date, with the difference being that time is intended as \"simulation time\" and is expected to be in seconds; date is a calendar date (from Dates.DateTime). Conversion between time and date is performed using the reference date and simulation starting time provided to the DataHandler.","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"The DataHandler has a caching mechanism in place: once a field is read and regridded, it is stored in the local cache to be used again (if needed). This is a least-recently-used (LRU) cache implemented in DataStructures, which removes the least-recently-used data when its maximum size is reached. The default maximum size is 128.","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"While the reading backend could be generic, at the moment, this module uses only the NCFileReader.","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"This extension is loaded when loading ClimaCore and NCDatasets are loaded. In addition to this, a Regridder is needed (which might require importing additional packages) - see Regridders for more information.","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"It is possible to pass down keyword arguments to underlying constructors in DataHandler with the regridder_kwargs and file_reader_kwargs. These have to be a named tuple or a dictionary that maps Symbols to values.","category":"page"},{"location":"datahandling/#Example","page":"DataHandling","title":"Example","text":"","category":"section"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"As an example, let us implement a simple linear interpolation for a variable u defined in the era5_example.nc NetCDF file. The file contains monthly averages starting from the year 2000.","category":"page"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"import ClimaUtilities.DataHandling\nimport ClimaCore\nimport NCDatasets\n# Loading ClimaCore and Interpolations automatically loads DataHandling\nimport Interpolations\n# This will load InterpolationsRegridder\n\nimport Dates\n\nunit_conversion_func = (data) -> 1000. * data\n\ndata_handler = DataHandling.DataHandler(\"era5_example.nc\",\n                                        \"u\",\n                                        target_space,\n                                        reference_date = Dates.DateTime(2000, 1, 1),\n                                        regridder_type = :InterpolationsRegridder,\n                                        file_reader_kwargs = (; preprocess_func = unit_conversion_func))\n\nfunction linear_interpolation(data_handler, time)\n    # Time is assumed to be \"simulation time\", ie seconds starting from reference_date\n\n    time_of_prev_snapshot = DataHandling.previous_time(data_handler, time)\n    time_of_next_snapshot = DataHandling.next_time(data_handler, time)\n\n    prev_snapshot = DataHandling.regridded_snaphsot(data_handler, time_of_prev_snapshot)\n    next_snapshot = DataHandling.regridded_snaphsot(data_handler, time_of_next_snapshot)\n\n    # prev and next snapshots are ClimaCore.Fields defined on the target_space\n\n    return @. prev_snapshot + (next_snapshot - prev_snapshot) *\n        (time - time_of_prev_snapshot) / (time_of_next_snapshot - time_of_prev_snapshot)\nend","category":"page"},{"location":"datahandling/#API","page":"DataHandling","title":"API","text":"","category":"section"},{"location":"datahandling/","page":"DataHandling","title":"DataHandling","text":"ClimaUtilities.DataHandling.DataHandler\nClimaUtilities.DataHandling.available_times\nClimaUtilities.DataHandling.available_dates\nClimaUtilities.DataHandling.previous_time\nClimaUtilities.DataHandling.next_time\nClimaUtilities.DataHandling.regridded_snapshot\nClimaUtilities.DataHandling.regridded_snapshot!","category":"page"},{"location":"datahandling/#ClimaUtilities.DataHandling.DataHandler","page":"DataHandling","title":"ClimaUtilities.DataHandling.DataHandler","text":"DataHandler(file_path::AbstractString,\n            varname::AbstractString,\n            target_space::ClimaCore.Spaces.AbstractSpace;\n            reference_date::Dates.DateTime = Dates.DateTime(1979, 1, 1),\n            t_start::AbstractFloat = 0.0,\n            regridder_type = nothing,\n            cache_max_size::Int = 128,\n            regridder_kwargs = (),\n            file_reader_kwargs = ())\n\nCreate a DataHandler to read varname from file_path and remap it to target_space.\n\nThe DataHandler maintains an LRU cache of Fields that were previously computed.\n\nCreating this object results in the file being accessed (to preallocate some memory).\n\nPositional arguments\n\nfile_path: Path of the NetCDF file that contains the data.\nvarname: Name of the dataset in the NetCDF that has to be read and processed.\ntarget_space: Space where the simulation is run, where the data has to be regridded to.\n\nKeyword arguments\n\nTime/date information will be ignored for static input files. (They are still set to make everything more type stable.)\n\nreference_date: Calendar date corresponding to the start of the simulation.\nt_start: Simulation time at the beginning of the simulation. Typically this is 0            (seconds), but if might be different if the simulation was restarted.\nregridder_type: What type of regridding to perform. Currently, the ones implemented are                   :TempestRegridder (using TempestRemap) and                   :InterpolationsRegridder (using Interpolations.jl). TempestRemap                   regrids everything ahead of time and saves the result to HDF5 files.                   Interpolations.jl is online and GPU compatible but not conservative.                   If the regridder type is not specified by the user, and multiple are                   available, the default :InterpolationsRegridder regridder is used.\ncache_max_size: Maximum number of regridded fields to store in the cache. If the cache                   is full, the least recently used field is removed.\nregridder_kwargs: Additional keywords to be passed to the constructor of the regridder.                     It can be a NamedTuple, or a Dictionary that maps Symbols to values.\nfile_reader_kwargs: Additional keywords to be passed to the constructor of the file reader.                       It can be a NamedTuple, or a Dictionary that maps Symbols to values.\n\n\n\n\n\n","category":"function"},{"location":"datahandling/#ClimaUtilities.DataHandling.available_times","page":"DataHandling","title":"ClimaUtilities.DataHandling.available_times","text":"available_times(data_handler::DataHandler)\n\nReturn the time in seconds of the snapshots in the data, measured considering the starting time of the simulation and the reference date\n\n\n\n\n\n","category":"function"},{"location":"datahandling/#ClimaUtilities.DataHandling.available_dates","page":"DataHandling","title":"ClimaUtilities.DataHandling.available_dates","text":"available_dates(data_handler::DataHandler)\n\nReturn the dates of the snapshots in the data.\n\n\n\n\n\n","category":"function"},{"location":"datahandling/#ClimaUtilities.DataHandling.previous_time","page":"DataHandling","title":"ClimaUtilities.DataHandling.previous_time","text":"previous_time(data_handler::DataHandler, time::AbstractFloat)\nprevious_time(data_handler::DataHandler, date::Dates.DateTime)\n\nReturn the time in seconds of the snapshot before the given time. If time is one of the snapshots, return itself.\n\n\n\n\n\n","category":"function"},{"location":"datahandling/#ClimaUtilities.DataHandling.next_time","page":"DataHandling","title":"ClimaUtilities.DataHandling.next_time","text":"next_time(data_handler::DataHandler, time::AbstractFloat)\nnext_time(data_handler::DataHandler, date::Dates.DateTime)\n\nReturn the time in seconds of the snapshot after the given time. If time is one of the snapshots, return the next time.\n\n\n\n\n\n","category":"function"},{"location":"datahandling/#ClimaUtilities.DataHandling.regridded_snapshot","page":"DataHandling","title":"ClimaUtilities.DataHandling.regridded_snapshot","text":"regridded_snapshot(data_handler::DataHandler, date::Dates.DateTime)\nregridded_snapshot(data_handler::DataHandler, time::AbstractFloat)\nregridded_snapshot(data_handler::DataHandler)\n\nReturn the regridded snapshot from data_handler associated to the given time (if relevant).\n\nThe time has to be available in the data_handler.\n\nregridded_snapshot potentially modifies the internal state of data_handler and it might be a very expensive operation.\n\n\n\n\n\n","category":"function"},{"location":"regridders/#Regridders","page":"Regridders","title":"Regridders","text":"","category":"section"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"Simulations often need to import external data directly onto the computational grid. The Regridders module implements different schemes to accomplish this goal.","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"Currently, Regridders comes with two implementations:","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"TempestRegridder uses TempestRemap (through ClimaCoreTempestRemap) to perform conservative interpolation onto lat-long grids. TempestRegridder only works for single-threaded CPU runs and works directly with files.\nInterpolationsRegridder uses Interpolations.jl to perform non-conservative linear interpolation onto lat-long(-z) grids. InterpolationsRegridder works directly with data.","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"⚠️ Note: While the Regridders can be used independently, most users will find their needs are immediately met by the SpaceVaryingInputs and TimeVaryingInputs interfaces. These higher-level objects implement everything that is needed to read a file to the model grid (internally using the Regridders).","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"If a regridder type is not specified by the user, and multiple are available, the InterpolationsRegridder will be used by default. At least one regridder extension must be loaded to be able to use regridding.","category":"page"},{"location":"regridders/#TempestRegridder","page":"Regridders","title":"TempestRegridder","text":"","category":"section"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"This extension is loaded when loading ClimaCoreTempestRemap","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"TempestRegridder performs conservative interpolation of lat-lon grids onto computational domains. TempestRegridder performs all the interpolation ahead of time and saves the regridded fields to HDF5 files that can be read during the simulation.","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"Currently, TempestRegridder does not support regridding on 3D domains. The InterpolationsRegridder described below can be used for these cases.","category":"page"},{"location":"regridders/#Example","page":"Regridders","title":"Example","text":"","category":"section"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"Assuming target_space is a ClimaCore 2D spherical field, the input data is the variable u in the file era5_example.nc, and we want to read the data associated with date target_date.","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"import ClimaUtilities.Regridders\nimport ClimaCoreTempestRemap\n# Loading ClimaCoreTempest automatically loads TempestRegridder\n\nreg = Regridders.TempestRegridder(target_space, \"regrid_output\", \"u\", \"era5_example.nc\")\n# When reg is created, the variable `u` is regridded and the output files\n# are saved to the `regrid_output` folder\n\nregridded_u = Regridders.regrid(reg, target_date)","category":"page"},{"location":"regridders/#InterpolationsRegridder","page":"Regridders","title":"InterpolationsRegridder","text":"","category":"section"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"This extension is loaded when loading ClimaCore and Interpolations","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"InterpolationsRegridder performs linear interpolation of input data (linear along each direction) and returns a ClimaCore Field defined on the target_space.","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"Currently, InterpolationsRegridder only supports spherical shells and extruded spherical shells (but it could be easily extended to other domains).","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"Note: it is easy to change the spatial interpolation type if needed.","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"InterpolationsRegridder are created once, they are tied to a target_space, but can be used with any input data. With MPI runs, every process computes the interpolating function. This is always done on the CPU and moved to GPU for accelerated runs.","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"By default, InterpolationsRegridder assumes you are interpolating on a globe and the default extrapolation boundary conditions are: periodic (along longitudes), copy (along latitude), and throwing an error (along z). These can be changed by passing the extrapolation_bc to the constructor of the regridder.","category":"page"},{"location":"regridders/#FAQ:-How-do-I-enable-linear-extrapolation-in-z?","page":"Regridders","title":"FAQ: How do I enable linear extrapolation in z?","text":"","category":"section"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"Create the regridder like this:","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"import Interpolations as Intp\n\nextrapolation_bc = (Intp.Periodic(), Intp.Flat(), Intp.Linear())\nregridder = InterpolationsRegridder(target_space; extrapolation_bc)","category":"page"},{"location":"regridders/#Example-2","page":"Regridders","title":"Example","text":"","category":"section"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"Assuming target_space is a ClimaCore 2D spherical field.","category":"page"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"import ClimaUtilities.Regridders\nimport ClimaCore, Interpolations\n# Loading ClimaCore and Interpolations automatically loads InterpolationsRegridder\n\nreg = Regridders.InterpolationsRegridder(target_space)\n\n# Now we can regrid any data\nlon = collect(-180:1:180)\nlat = collect(-90:1:90)\n# It has to be lon, lat (because this is the assumed order in the CF conventions)\ndimensions = (lon, lat)\n\ndata = rand((length(lon), length(lat)))\n\ninterpolated_data = Regridders.InterpolationsRegridder(reg, data, dimensions)\ninterpolated_2data = Regridders.InterpolationsRegridder(reg, 2 .* data, dimensions)","category":"page"},{"location":"regridders/#API","page":"Regridders","title":"API","text":"","category":"section"},{"location":"regridders/","page":"Regridders","title":"Regridders","text":"ClimaUtilities.Regridders.TempestRegridder\nClimaUtilities.Regridders.InterpolationsRegridder\nClimaUtilities.Regridders.regrid","category":"page"},{"location":"regridders/#ClimaUtilities.Regridders.InterpolationsRegridder","page":"Regridders","title":"ClimaUtilities.Regridders.InterpolationsRegridder","text":"InterpolationsRegridder(target_space::ClimaCore.Spaces.AbstractSpace\n                        [; extrapolation_bc::Tuple])\n\nAn online regridder that uses Interpolations.jl\n\nCurrently, InterpolationsRegridder is only implemented for LatLong and LatLongZ spaces. It performs linear interpolation along each of the directions (separately). By default, it imposes periodic boundary conditions for longitude, flat for latitude, and throwing errors when extrapolating in z. This can be customized by passing the extrapolation_bc keyword argument.\n\nInterpolationsRegridder is GPU and MPI compatible in the simplest possible way: each MPI process has the entire input data and everything is copied to GPU.\n\nKeyword arguments\n\nThe optional keyword argument extrapolation_bc controls what should be done when the interpolation point is not in the domain of definition. This has to be a tuple of N elements, where N is the number of spatial dimensions. For 3D spaces, the default is (Interpolations.Periodic(), Interpolations.Flat(), Interpolations.Throw()).\n\n\n\n\n\n","category":"function"},{"location":"regridders/#ClimaUtilities.Regridders.regrid","page":"Regridders","title":"ClimaUtilities.Regridders.regrid","text":"regrid(regridder::InterpolationsRegridder, data, dimensions)::Field\n\nRegrid the given data as defined on the given dimensions to the target_space in regridder.\n\nThis function is allocating.\n\n\n\n\n\n","category":"function"},{"location":"climaartifacts/#ClimaArtifacts","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"","category":"section"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"Julia artifacts are pieces of data that can be distributed alongside a package. Julia artifacts were developed to distribute application binaries (e.g., compiled libraries). In CliMA, we use them to distribute data required to perform our simulations (e.g., input data).","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"The ClimaArtifacts module extends the Julia artifact system to solve two issues:","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"Ensuring that artifacts can be gracefully acquired by parallel runs;\nTagging artifacts that are accessed during a simulation.","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"We will examine these two problems below. In the meantime, this entire documentation page can be summarized in a one short directive for package developers:","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"Instead of accessing artifacts with  ArtifactWrappers.jl or using  Julia artifacts directly, use the @clima_artifact macro instead.","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"Also, keep in mind that","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"⚠️ Note: Julia artifacts are always entire folders, never single files!","category":"page"},{"location":"climaartifacts/#Julia-artifacts-and-MPI","page":"ClimaArtifacts","title":"Julia artifacts and MPI","text":"","category":"section"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"Package developers can specify one of two modes for any given artifact: greedy (default) or lazy download. Artifact that are not marked as lazy are automatically downloaded by Julia when the package is instantiated. On the other hand, lazy artifacts are downloaded the first time they are accessed.","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"CliMA packages can distribute tens of artifacts that are relevant for very different types of simulations, and it is a good idea to mark artifacts as lazy unless they are strictly required for the operation of the package (e.g., the orbital parameters in Insolation.jl).","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"Lazy artifacts are incompatible with MPI. In parallel runs, each process tries to download the same file, resulting in a race condition and corrupted files (not to mention tens of processing pinging the same server at the same time). ClimaArtifacts implements a new macro, @clima_artifact, to solve this problem.","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"@clima_artifact is a near drop-in replacement for the @artifact_str Julia macro.","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"For greedy artifacts and non-MPI runs, it is possible to simply call @clima_artifact(artifact_name). This will return the path of the artifact folder. This macro will fail for lazy artifacts. In that case, one has to also pass the ClimaComms.jl context. The context is required because @clima_artifact needs to synchronize different MPI processes.","category":"page"},{"location":"climaartifacts/#Example","page":"ClimaArtifacts","title":"Example","text":"","category":"section"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"This extension is loaded when loading ClimaComms","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"Assume socrates is a lazy artifact, we can access the socrates artifact folder as in","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"using ClimaUtilities.ClimaArtifacts\n# If the artifact is lazy, we also need LazyArtifacts\nusing LazyArtifacts\n\nimport ClimaComms\n# When loading ClimaComms, a Julia extension for ClimaUtilities will be loaded\n\nmy_mpi_context = ClimaComms.context()\n\nsocrates_path_folder = @clima_artifact(\"socrates\", context)","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"The @clima_artifact macro is executed at parse time when the argument is a literal string (e.g., @clima_artifact(\"socrates\")), and at runtime when it is a variable @clima_artifact(artifact_name).","category":"page"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"Note: context is a positional argument, not a keyword one. Calling @clima_artifact(\"socrates\"; context) will fail. (This is due to how Julia macros handle keyword arguments)","category":"page"},{"location":"climaartifacts/#Tagging-artifacts","page":"ClimaArtifacts","title":"Tagging artifacts","text":"","category":"section"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"A full climate simulation requires lots of external input data. Most of this data comes from scientific experiments that have to be properly acknowledged. ClimaArtifacts allows users to know what artifacts were used in a given simulation. As long as artifacts are being accessed with @clima_artifacts, the ClimaArtifacts keeps track of what is being used. The set of artifacts accessed can be obtained with ClimaArtifacts.accessed_artifacts.","category":"page"},{"location":"climaartifacts/#Example-2","page":"ClimaArtifacts","title":"Example","text":"","category":"section"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"using ClimaUtilities.ClimaArtifacts\nart1 = @clima_artifact(\"socrates\")\nart2 = @clima_artifact(\"zeno\")\n\nClimaArtifacts.accessed_artifacts()\n# Set([\"socrates\", \"zeno\"])","category":"page"},{"location":"climaartifacts/#API","page":"ClimaArtifacts","title":"API","text":"","category":"section"},{"location":"climaartifacts/","page":"ClimaArtifacts","title":"ClimaArtifacts","text":"ClimaUtilities.ClimaArtifacts.@clima_artifact\nClimaUtilities.ClimaArtifacts.accessed_artifacts","category":"page"},{"location":"climaartifacts/#ClimaUtilities.ClimaArtifacts.@clima_artifact","page":"ClimaArtifacts","title":"ClimaUtilities.ClimaArtifacts.@clima_artifact","text":"@clima_artifact(artifact_name, context = nothing)\n\nReturn the path of the given artifact name. The path is always a folder (Julia artifacts can contain multiple files).\n\nThis macro plays nicely with MPI contexts and lazily downloaded artifacts. This is achieved by ensuring that only one process downloads the file, while the other wait until the file is fully downloaded.\n\nPassing the context is required only for lazy artifacts.\n\n\n\n\n\n","category":"macro"},{"location":"climaartifacts/#ClimaUtilities.ClimaArtifacts.accessed_artifacts","page":"ClimaArtifacts","title":"ClimaUtilities.ClimaArtifacts.accessed_artifacts","text":"accessed_artifacts()\n\nReturn a set with the names of the artifacts accessed using the @clima_artifact macro.\n\n\n\n\n\n","category":"function"},{"location":"datastructures/#DataStructures","page":"DataStructures","title":"DataStructures","text":"","category":"section"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"The DataStructures module implements helpful data structures to be used by other ClimaUtilities.jl modules or external packages.","category":"page"},{"location":"datastructures/#LRUCache","page":"DataStructures","title":"LRUCache","text":"","category":"section"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"DataStructures implements an LRUCache, which is used in both DataHandlingExt and NCFileReaderExt. LRUCache can be used to store pieces of information that need to be accessed multiple times and may be expensive to compute, such as regridded fields or loaded files. Instead of recomputing the values each time they're needed, the previously-computed information is saved in the cache and retrieved directly from it. To prevent the cache from growing so large that it takes up significant memory, the least-recently-used (LRU) scheme maintains a maximum cache size: every time adding an element to the cache would lead its size to grow larger thant the maximum allowed, the element that was accessed the least recently is deleted first.","category":"page"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"Note: all the methods supported by dictionaries are currently implemented.","category":"page"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"If you need one that is not implemented, please open an issue or a pull request.","category":"page"},{"location":"datastructures/#Example","page":"DataStructures","title":"Example","text":"","category":"section"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"In many ways, LRUCaches behave like Julia dictionaries. To use one, we first need to initialize the empty cache specifying types of keys and values and optionally the maximum allowed size:","category":"page"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"import ClimaUtilities.DataStructures\ncache = DataStructures.LRUCache{Int, Int}(; max_size = 128)","category":"page"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"Once we have the cache, we can access and insert elements with get!. get! retrieves the value associated to the key if avaialble, otherwise it inserts a new key with a provided default. The default can be passed as third argument or can be the return statement of a function provided as first (as typically done in do blocks). Continuing the example above","category":"page"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"println(\"The value associated to 1 is: \", get!(cache, 1, 10))\nother_value = get!(cache, 2) do\n    return 20\nend","category":"page"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"This cache can be used to implement some recursive function more efficiently, as in the famous case of the factorial:","category":"page"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"function factorial(n)\n    n in (0, 1) && return 1\n    return n * get!(cache, n - 1, factorial(n - 1))\nend\n# The first time we call factorial it will compute everything\n@time factorial(10)\n# The second time it will only compute the last element\n@time factorial(11)","category":"page"},{"location":"datastructures/#API","page":"DataStructures","title":"API","text":"","category":"section"},{"location":"datastructures/","page":"DataStructures","title":"DataStructures","text":"ClimaUtilities.DataStructures.LRUCache\nBase.get!","category":"page"},{"location":"datastructures/#ClimaUtilities.DataStructures.LRUCache","page":"DataStructures","title":"ClimaUtilities.DataStructures.LRUCache","text":"LRUCache{K, V}(; max_size::Int = 128) where {K, V}\n\nConstruct an empty LRUCache with a maximum size of max_size.\n\n\n\n\n\n","category":"type"},{"location":"datastructures/#Base.get!","page":"DataStructures","title":"Base.get!","text":"Base.get!(cache::LRUCache{K, V}, key::K, default::V) where {K, V}\n\nGet the value associated with key in cache. If the key is not in the cache, add it with the value default. In any case, update the key's priority and make sure the cache doesn't exceed its maximum size.\n\n\n\n\n\nBase.get!(default::Callable, cache::LRUCache{K, V}, key::K) where {K, V}\n\nGet the value associated with key in cache. If the key is not in the cache, add it with the value default(). In any case, update the key's priority and make sure the cache doesn't exceed its maximum size.\n\nThis method is intended to be used with do block syntax.\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#TimeManager","page":"TimeManager","title":"TimeManager","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"This module contains functions that handle dates and times in simulations. The functions in this module often call functions from Julia's Dates module.","category":"page"},{"location":"timemanager/#TimeManager-API","page":"TimeManager","title":"TimeManager API","text":"","category":"section"},{"location":"timemanager/","page":"TimeManager","title":"TimeManager","text":"ClimaUtilities.TimeManager.to_datetime\nClimaUtilities.TimeManager.strdate_to_datetime\nClimaUtilities.TimeManager.datetime_to_strdate\nClimaUtilities.TimeManager.trigger_callback\nClimaUtilities.TimeManager.Monthly\nClimaUtilities.TimeManager.EveryTimestep","category":"page"},{"location":"timemanager/#ClimaUtilities.TimeManager.to_datetime","page":"TimeManager","title":"ClimaUtilities.TimeManager.to_datetime","text":"to_datetime(date)\n\nConvert a DateTime-like object (e.g. DateTimeNoLeap) to a DateTime. We need this since some data files we use contain DateTimeNoLeap objects for dates, which can't be used for math with DateTimes. The DateTimeNoLeap type uses the Gregorian calendar without leap years, while the DateTime type uses Gregorian calendar with leap years.\n\nFor consistency, all input data files should have dates converted to DateTime before being used in a simulation.\n\nThis function is similar to reinterpret in CFTime.jl.\n\nArguments\n\ndate: DateTime-like object to be converted to DateTime\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ClimaUtilities.TimeManager.strdate_to_datetime","page":"TimeManager","title":"ClimaUtilities.TimeManager.strdate_to_datetime","text":"strdate_to_datetime(strdate::String)\n\nConvert from String (\"YYYYMMDD\") to Date format, required by the official AMIP input files.\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ClimaUtilities.TimeManager.datetime_to_strdate","page":"TimeManager","title":"ClimaUtilities.TimeManager.datetime_to_strdate","text":"datetime_to_strdate(datetime::Dates.DateTime)\n\nConvert from DateTime to String (\"YYYYMMDD\") format.\n\n\n\n\n\n","category":"function"},{"location":"timemanager/#ClimaUtilities.TimeManager.trigger_callback","page":"TimeManager","title":"ClimaUtilities.TimeManager.trigger_callback","text":"trigger_callback(date_nextcall::Dates.DateTime,\n    date_current::Dates.DateTime,\n    ::Monthly,\n    func::Function,)\n\nIf the current date is equal to or later than the \"next call\" date at time 00:00:00, call the callback function and increment the next call date by one month. Otherwise, do nothing and leave the next call date unchanged.\n\nThe tuple of arguments func_args must match the types, number, and order of arguments expected by func.\n\nArguments\n\ndate_nextcall::DateTime the next date to call the callback function at or after\ndate_current::DateTime the current date of the simulation\nsave_freq::AbstractFrequency frequency with which to trigger callback\nfunc::Function function to be triggered if date is at or past the next call date\nfunc_args::Tuple a tuple of arguments to be passed into the callback function\n\n\n\n\n\n","category":"function"},{"location":"inputs/#SpaceVaringInputs-and-TimeVaryingInputs","page":"Space and Time Inputs","title":"SpaceVaringInputs and TimeVaryingInputs","text":"","category":"section"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"Most models require external inputs to work. Examples of inputs are an analytic function that prescribes the sea-surface temperature in time, or a file that describes the types of plants on the surface of the globe. The SpaceVaringInputs and TimeVaryingInputs modules provide a unified infrastructure to handle all these cases.","category":"page"},{"location":"inputs/#TimeVaryingInputs","page":"Space and Time Inputs","title":"TimeVaryingInputs","text":"","category":"section"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"This extension is loaded when loading ClimaCore is loaded. In addition to this, if NetCDF files are used, NCDatasets has to be loaded too. Finally, a Regridder is needed (which might require importing additional packages).","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"A TimeVaryingInput is an object that knows how to fill a ClimaCore Field at a given simulation time t. TimeVaryingInputs can be constructed in a variety of ways, from using analytic functions, to NetCDF data. They expose one interface, evaluate!(dest_field, tv, time), which can be used by model developers to update their Fields.","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"This example shows that TimeVaryingInput can take different types of inputs and be used with a single interface (evaluate!). In all of this, TimeVaryingInputs internally handle all the complexity related to reading files (using FileReaders), dealing with parallelism and GPUs, regridding onto the computational domains (using Regridders and DataHandling), and so on.","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"TimeVaryingInputs support:","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"analytic functions of time;\npairs of 1D arrays (for PointSpaces);\n2/3D NetCDF files;\nlinear interpolation in time (default) and nearest neighbors.","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"It is possible to pass down keyword arguments to underlying constructors in the Regridder with the regridder_kwargs and file_reader_kwargs. These have to be a named tuple or a dictionary that maps Symbols to values.","category":"page"},{"location":"inputs/#Example","page":"Space and Time Inputs","title":"Example","text":"","category":"section"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"Let target_space be the computational domain (a ClimaCore Space) and cesm_albedo.nc a NetCDF file containing albedo data as a function of time in a variable named alb.","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"import ClimaUtilities: TimeVaryingInputs\nimport ClimaCore\nimport NCDatasets\nimport ClimaCoreTempestRemap\n# Loading ClimaCore, NCDatasets, ClimaCoreTempestRemap loads the extensions we need\n\nfunction evolve_model(albedo_tv, albedo_field)\n    new_t = t + dt\n    # First, we update the albedo to the new time\n    evaluate!(albedo_field, albedo_tv, new_t)\n    # Now we can do all the operations we want we albedo_filed\n    # rhs = ...\nend\n\n# Let us prepare an empty Field that will contain the albedo\nalbedo_field = zero(target_space)\n\n# If the albedo is an analytic function of time\nalbedo_tv_an = TimeVaryingInput((t) -> 0.5)\n\n# If the albedo comes from data\n\n# reference_date is the calendar date at the beginning of our simulation\nreference_date = Dates.DateTime(2000, 1, 1)\nalbedo_tv = TimeVaryingInputs.TimeVaryingInput(\"cesem_albedo.nc\", \"alb\", target_space;\n                                               reference_date, regridder_kwargs = (; regrid_dir = \"/tmp\"))\n# When using data from files, the data is automatically interpolated to the correct\n# time\n\n# In either cases, we can always call evolve_model(albedo_tv, albedo_field), so\n# model developers do not have to worry about anything :)","category":"page"},{"location":"inputs/#SpaceVaryingInputs","page":"Space and Time Inputs","title":"SpaceVaryingInputs","text":"","category":"section"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"This extension is loaded when loading ClimaCore is loaded. In addition to this, if NetCDF files are used, NCDatasets has to be loaded too. Finally, a Regridder is needed (which might require importing additional packages).","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"SpaceVaryingInputs uses the same building blocks as TimeVaryingInput (chiefly the DataHandling module) to construct a Field from different sources.","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"TimeVaryingInputs support:","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"analytic functions of coordinates;\npairs of 1D arrays (for columns);\n2/3D NetCDF files.","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"In some ways, a SpaceVaryingInput can be thought as an alternative constructor for a ClimaCore Field.","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"It is possible to pass down keyword arguments to underlying constructors in the Regridder with the regridder_kwargs and file_reader_kwargs. These have to be a named tuple or a dictionary that maps Symbols to values.","category":"page"},{"location":"inputs/#Example-2","page":"Space and Time Inputs","title":"Example","text":"","category":"section"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"Let target_space be a ClimaCore Space where we want the Field to be defined on and cesm_albedo.nc a NetCDF file containing albedo data as a time in a variable named alb.","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"julia import ClimaUtilities: SpaceVaryingInputs import ClimaCore import NCDatasets import ClimaCoreTempestRemap","category":"page"},{"location":"inputs/#Loading-ClimaCore,-NCDatasets,-ClimaCoreTempestRemap-loads-the-extensions-we-need","page":"Space and Time Inputs","title":"Loading ClimaCore, NCDatasets, ClimaCoreTempestRemap loads the extensions we need","text":"","category":"section"},{"location":"inputs/#Albedo-as-an-analytic-function-of-lat-and-lon","page":"Space and Time Inputs","title":"Albedo as an analytic function of lat and lon","text":"","category":"section"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"albedolatlonfun = (coord) -> 0.5 * coord.long * coord.lat","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"albedo = SpaceVaryingInputs.SpaceVaryingInput(albedolatlonfun)","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"albedofromfile = SpaceVaryingInputs.SpaceVaryingInput(\"cesmalbedo.nc\", \"alb\", targetspace, regridderkwargs = (; regriddir = \"/tmp\"))","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"\n## API\n","category":"page"},{"location":"inputs/","page":"Space and Time Inputs","title":"Space and Time Inputs","text":"@docs ClimaUtilities.SpaceVaryingInputs.SpaceVaryingInput ClimaUtilities.TimeVaryingInputs.AbstractInterpolationMethod ClimaUtilities.TimeVaryingInputs.NearestNeighbor ClimaUtilities.TimeVaryingInputs.LinearInterpolation ClimaUtilities.TimeVaryingInputs.evaulate! Base.in Base.close ```","category":"page"},{"location":"#ClimaUtilities.jl","page":"Overview","title":"ClimaUtilities.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"ClimaUtilities.jl provides a toolkit of functions that cover needs that are shared across repositories within the CliMA project.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"ClimaUtilities.jl is designed to have the minimum possible number of direct dependencies. Instead, everything is implemented in Julia extensions and modules are conditionally loaded when key packages are imported.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"ClimaUtilities.jl also aims to provide an abstraction to commonly required features (e.g., regridding), so that improvements can be made under the hood without affecting users.","category":"page"},{"location":"#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"#ClimaArtifacts","page":"Overview","title":"ClimaArtifacts","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"ClimaArtifacts provides a MPI-safe way to lazily download artifacts and to tag artifacts that are being accessed in a given simulation.","category":"page"},{"location":"#SpaceVaryingInputs-and-TimeVaryingInputs","page":"Overview","title":"SpaceVaryingInputs and TimeVaryingInputs","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"SpaceVaryingInputs and TimeVaryingInputs provide functions to seamlessly map input to a Field. The input could be a function, a 1D array, a NetCDF file, and it could be static or time varying. SpaceVaryingInputs and TimeVaryingInputs objects can be evaluate!d to set the value of Field (potentially using the Regridders). TimeVaryingInputs implement linear and nearest neighbor interpolations.","category":"page"},{"location":"#FileReaders","page":"Overview","title":"FileReaders","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The FileReaders module provides a way to efficiently read data from files. Efficiently might mean chunked/threaded/cached/something else. Currently, this is mostly and interface barrier to provide a path for future improvements.","category":"page"},{"location":"#Regridders","page":"Overview","title":"Regridders","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"ClimaUtilities comes with two modules to map rectangular grids two (extruded) finite spectral elements, InterpolationsRegridder and TempestRegridder. These modules are primarily used to ingest data and resample it onto the computational grid.","category":"page"},{"location":"#InterpolationsRegridder","page":"Overview","title":"InterpolationsRegridder","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"InterpolationsRegridder uses Interpolations.jl to perform non-conservative linear interpolation onto lat-long(-z) grids. InterpolationsRegridder is fully compatible with MPI/GPUs.","category":"page"},{"location":"#TempestRegridder","page":"Overview","title":"TempestRegridder","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"TempestRegridder uses TempestRemap to perform conservative interpolation onto lat-long grids.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"⚠️ Note: At the moment, TempestRegridder does not support MPI/GPUs and can only perform interpolation onto lat-long grids (not on z).","category":"page"},{"location":"#OutputPathGenerator","page":"Overview","title":"OutputPathGenerator","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"OutputPathGenerator handles the directory structure for the output of a simulation. If you are a package developer, use this module to set up the output path for your simulation.","category":"page"},{"location":"#DataHandling","page":"Overview","title":"DataHandling","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The DataHandling module bundles a Regridder and a FileReader together to serve regridded fields at a given time upon request. The main interface for DataHandling is regridded_snapshot(data_handler, date), a function that returns a Field with data read from file for the given date. The DataHandler maintains an least-recently-used (LRU) cache of regridded fields to amortize the cost of (expensive) regridding operations.","category":"page"},{"location":"#DataStructures","page":"Overview","title":"DataStructures","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The DataStructures module implements helpful data structures to be used by other ClimaUtilities.jl modules or external packages. Currently it contains an LRU cache that is used in DataHandlingExt and NCFileReaderExt.","category":"page"},{"location":"outputpathgenerator/#OutputPathGenerator","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"","category":"section"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"The OutputPathGenerator module provides tools for preparing the directory structure for your simulation output. This helps you organize your simulation results efficiently and avoid overwriting existing data.","category":"page"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"The module offers one function, generate_output_path. The function takes three arguments:","category":"page"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"output_path: The base directory path for your simulation output.\nstyle (Optional): The desired style for output management (defaults to ActiveLinkStyle).\ncontext (Optional): the ClimaComms.context. This is required in MPI runs to ensure that all the MPI processes agree on the folder structure.","category":"page"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"The function processes the output_path based on the chosen style and returns the final path where you should write your simulation output.","category":"page"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"You should use generate_output_path at the beginning of your simulation and use the return value as the base directory where you save all the output your code produces.","category":"page"},{"location":"outputpathgenerator/#Available-Styles","page":"OutputPathGenerator","title":"Available Styles","text":"","category":"section"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"The module currently offers two different styles for handling the output directory:","category":"page"},{"location":"outputpathgenerator/#RemovePreexistingStyle-(Destructive)","page":"OutputPathGenerator","title":"RemovePreexistingStyle (Destructive)","text":"","category":"section"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"This style directly uses the provided output_path as the final output directory. Important: If a directory already exists at the specified path, it will be removed completely (including any subfolders and files) without confirmation. Use this style cautiously!","category":"page"},{"location":"outputpathgenerator/#ActiveLinkStyle-(Non-Destructive)","page":"OutputPathGenerator","title":"ActiveLinkStyle (Non-Destructive)","text":"","category":"section"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by outputpath. It also creates a symbolic link named `outputactive` that points to the current active subfolder. This allows you to easily access the latest simulation results.","category":"page"},{"location":"outputpathgenerator/#Example","page":"OutputPathGenerator","title":"Example","text":"","category":"section"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"Let's assume your output_path is set to data.","category":"page"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"If data doesn't exist, the module creates it and returns data/output_0000. In doing this, a link data/output_active to data/output_0000 is created so that you can always access your data in data/output_active.\nIf data exists and contains an output_active link pointing to data/output_0005, output_active is updated to point to a new subfolder called data/output_0006\nIf data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it.","category":"page"},{"location":"outputpathgenerator/#A-note-for-Windows-users","page":"OutputPathGenerator","title":"A note for Windows users","text":"","category":"section"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"Windows does not always allow the creation of symbolic links by unprivileged users, so some details about links might be slightly different depending on your system. If you are using Windows, please have a look at docstring on the ActiveLinkStyle to learn more about possible differences.","category":"page"},{"location":"outputpathgenerator/#API","page":"OutputPathGenerator","title":"API","text":"","category":"section"},{"location":"outputpathgenerator/","page":"OutputPathGenerator","title":"OutputPathGenerator","text":"ClimaUtilities.OutputPathGenerator.generate_output_path\nClimaUtilities.OutputPathGenerator.RemovePreexistingStyle\nClimaUtilities.OutputPathGenerator.ActiveLinkStyle","category":"page"},{"location":"outputpathgenerator/#ClimaUtilities.OutputPathGenerator.generate_output_path","page":"OutputPathGenerator","title":"ClimaUtilities.OutputPathGenerator.generate_output_path","text":"generate_output_path(output_path,\n                     context = nothing,\n                     style::OutputPathGeneratorStyle = ActiveLinkStyle())\n\nProcess the output_path and return a string with the path where to write the output.\n\nThe context is a ClimaComms context and is required for MPI runs.\n\nHow the output should be structured (in terms of directory tree) is determined by the style.\n\nStyles\n\nRemovePreexistingStyle: the output_path provided is the actual output path. If a directory already exists there, remove it without asking for confirmation.\nActiveLinkStyle: the output_path returned is a new folder of the form output_path/output_1234, where the number is incremented every time this function is called. ActiveLinkStyle also creates a link output_path/output_active that ensures that the most recent output is always accessible at the output_path/output_active path. This is style is non-destructive.\n\n(Note, \"styles\" have nothing to do with Julia traits.)\n\n\n\n\n\ngenerate_output_path(::RemovePreexistingStyle, output_path, context = nothing)\n\nDocumentation for this function is in the RemovePreexistingStyle struct.\n\n\n\n\n\ngenerate_output_path(::ActiveLinkStyle, output_path, context = nothing)\n\nDocumentation for this function is in the ActiveLinkStyle struct.\n\n\n\n\n\n","category":"function"},{"location":"outputpathgenerator/#ClimaUtilities.OutputPathGenerator.RemovePreexistingStyle","page":"OutputPathGenerator","title":"ClimaUtilities.OutputPathGenerator.RemovePreexistingStyle","text":"RemovePreexistingStyle\n\nWith this option, the output directory is directly specified. If the directory already exists, remove it. No confirmation is asked, so use at your own risk.\n\n\n\n\n\n","category":"type"},{"location":"outputpathgenerator/#ClimaUtilities.OutputPathGenerator.ActiveLinkStyle","page":"OutputPathGenerator","title":"ClimaUtilities.OutputPathGenerator.ActiveLinkStyle","text":"ActiveLinkStyle\n\nThis style generates a unique output path within a base directory specified by output_path. It ensures the base directory exists and creates it if necessary. Additionally, it manages a sequence of subfolders and a symbolic link named \"output_active\" for convenient access to the active output location.\n\nThis style is designed to:\n\nbe non-destructive,\nprovide a deterministic and fixed path for the latest available data,\nand have nearly zero runtime overhead.\n\ngenerate_output_path returns path to the newly created folder with the next available increment (of the form output_1234), and ensures that a valid output_active link points to that folder.\n\nExamples:\n\nLet us assume that output_path = dormouse.\n\ndormouse does not exist in the current working directory: ActiveLinkStyle will create it and return dormouse/output_0000. In the process, a symlink dormouse/output_active is also created. This symlink points to dormouse/output_0000.\ndormouse exists and contains a output_active link that points to dormouse/output_0005, ActiveLinkStyle will a create new directory dormouse/output_0006, return this path, and change the output_active to point to this directory.\ndormouse exists and does not contain a output_active, ActiveLinkStyle will check if any dormouse/output_XXXX exists. If not, it creates dormouse/output_0000 and a link dormouse/output_active that points to this directory.\n\nA note for Windows users\n\nWindows does not always allow the creation of symbolic links by unprivileged users. This depends on the version of Windows, but also some of its settings. When the creation of symbolic links is not possible, OutputPathGenerator will create NTFS junction points instead. Junction points are similar to symbolic links, with the main difference that they have to refer to directories and they have to be absolute paths. As a result, on systems that do not allow unprivileged users to create symbolic links, moving the base output folder results in breaking the output_active link.\n\n\n\n\n\n","category":"type"},{"location":"filereaders/#FileReaders","page":"FileReaders","title":"FileReaders","text":"","category":"section"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"Reading files is a common need for most scientific projects. This can come with a series of problems that have to be solved, from performance (accessing can be a very computationally expensive operation), to dealing with multiple files that are logically connected. The FileReaders provides an abstraction layer to decouple the scientific needs with the technical implementation so that file processing can be optimized and extended independently of the rest of the model.","category":"page"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"At this point, the implemented FileReaders are always linked to a specific variable and they come with a caching system to avoid unnecessary reads.","category":"page"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"Future extensions might include:","category":"page"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"dealing with multiple files containing the same variables (e.g. time series when the dates are split in different files);\ndoing chunked reads;\nasync reads.","category":"page"},{"location":"filereaders/#NCFileReaders","page":"FileReaders","title":"NCFileReaders","text":"","category":"section"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"This extension is loaded when loading NCDatasets","category":"page"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"The only file reader currently implemented is the NCFileReader, used to read NetCDF files. Each NCFileReader is associated to one particular file and variable (but multiple NCFileReaders can share the same file).","category":"page"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"Once created, NCFileReader is accessed with the read(file_reader, date) function, which returns the Array associated to given date (if available). The date can be omitted if the data is static.","category":"page"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"NCFileReaders implement two additional features: (1) optional preprocessing, and (2) cache reads. NCFileReaders can be created with a preprocessing_func keyword argument, function is applied to the read datasets when reading. preprocessing_func should be a lightweight function, such as removing NaNs or changing units. Every time read(file_reader, date) is called, the NCFileReader checks if the date is currently stored in the cache. If yes, it just returns the value (without accessing the disk). If not, it reads and process the data and adds it to the cache. This uses a least-recently-used (LRU) cache implemented in DataStructures, which removes the least-recently-used data stored in the cache when its maximum size is reached (the default max size is 128).","category":"page"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"It is good practice to always close the NCFileReaders when they are no longer needed. The function close_all_ncfiles closes all the ones that are currently open.","category":"page"},{"location":"filereaders/#Example","page":"FileReaders","title":"Example","text":"","category":"section"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"Assume you have a file era5_2000.nc, which contains two variables u and v, defined for the year 2000.","category":"page"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"import ClimaUtilities.FileReaders\nimport NCDatasets\n# Loading NCDatasets automatically loads `NCFileReaders`\n\nu_var = FileReaders.NCFileReader(\"era5_2000.nc\", \"u\")\n# Change units for v\nv_var = FileReaders.NCFileReader(\"era5_2000.nc\", \"u\", preprocess_func = x -> 1000x)\n\ndates = FileReaders.available_dates(u_var)\n# dates is a vector of Dates.DateTime\n\nfirst_date = dates[begin]\n\n# The first time we call read, the file is accessed and read\nu_array = FileReaders.read(u_var, first_date)\n# As the name suggests, u_array is an Array\n\n# All the other times, we access the cache, so no IO operation is involved\nu_array_again = FileReaders.read(u_var, first_date)\n\nclose(u_var)\nclose(v_var)\n# Alternatively: FileReaders.close_all_ncfiles()","category":"page"},{"location":"filereaders/#API","page":"FileReaders","title":"API","text":"","category":"section"},{"location":"filereaders/","page":"FileReaders","title":"FileReaders","text":"ClimaUtilities.FileReaders.NCFileReader\nClimaUtilities.FileReaders.read\nClimaUtilities.FileReaders.read!\nClimaUtilities.FileReaders.available_dates\nClimaUtilities.FileReaders.close_all_ncfiles\nBase.close","category":"page"},{"location":"filereaders/#ClimaUtilities.FileReaders.NCFileReader","page":"FileReaders","title":"ClimaUtilities.FileReaders.NCFileReader","text":"FileReaders.NCFileReader(\n    file_path::AbstractString,\n    varname::AbstractString;\n    preprocess_func = identity,\n    cache_max_size:Int = 128,\n)\n\nA struct to efficiently read and process NetCDF files.\n\n\n\n\n\n","category":"function"},{"location":"filereaders/#ClimaUtilities.FileReaders.read","page":"FileReaders","title":"ClimaUtilities.FileReaders.read","text":"read(file_reader::NCFileReader, date::Dates.DateTime)\n\nRead and preprocess the data at the given date.\n\n\n\n\n\nread(file_reader::NCFileReader)\n\nRead and preprocess data (for static datasets).\n\n\n\n\n\n","category":"function"},{"location":"filereaders/#ClimaUtilities.FileReaders.read!","page":"FileReaders","title":"ClimaUtilities.FileReaders.read!","text":"read!(dest, file_reader::NCFileReader)\n\nRead and preprocess data (for static datasets), saving the output to dest.\n\n\n\n\n\nread!(dest, file_reader::NCFileReader, date::Dates.DateTime)\n\nRead and preprocess the data at the given date, saving the output to dest.\n\n\n\n\n\n","category":"function"},{"location":"filereaders/#ClimaUtilities.FileReaders.available_dates","page":"FileReaders","title":"ClimaUtilities.FileReaders.available_dates","text":"available_dates(file_reader::NCFileReader)\n\nReturns the dates in the given file.\n\n\n\n\n\n","category":"function"},{"location":"filereaders/#ClimaUtilities.FileReaders.close_all_ncfiles","page":"FileReaders","title":"ClimaUtilities.FileReaders.close_all_ncfiles","text":"close_all_ncfiles()\n\nClose all the NCFileReader currently open.\n\n\n\n\n\n","category":"function"},{"location":"filereaders/#Base.close","page":"FileReaders","title":"Base.close","text":"close(data_handler::DataHandler)\n\nClose any file associated to the given data_handler.\n\n\n\n\n\nclose(time_varying_input::TimeVaryingInputs.AbstractTimeVaryingInput)\n\nClose files associated to the time_varying_input.\n\n\n\n\n\nclose(time_varying_input::InterpolatingTimeVaryingInput23D)\n\nClose files associated to the time_varying_input.\n\n\n\n\n\nclose(file_reader::NCFileReader)\n\nClose NCFileReader. If no other NCFileReader is using the same file, close the NetCDF file.\n\n\n\n\n\n","category":"function"}]
}
